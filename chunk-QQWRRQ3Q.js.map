{"version":3,"sources":["node_modules/@angular/material/fesm2022/slide-toggle.mjs","node_modules/compute-scroll-into-view/src/index.ts","node_modules/@angular/cdk/fesm2022/text-field.mjs","node_modules/@angular/material/fesm2022/input-value-accessor-D1GvPuqO.mjs","node_modules/@angular/material/fesm2022/input.mjs","node_modules/@angular/material/fesm2022/sidenav.mjs","projects/showcase/src/app/shared/layout/layout-toolbar-menu.component.ts","projects/showcase/src/app/demo/demo-index.component.ts","projects/showcase/src/app/demo/demo-index.component.html"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, ChangeDetectorRef, EventEmitter, HostAttributeToken, booleanAttribute, numberAttribute, forwardRef, Component, ViewEncapsulation, ChangeDetectionStrategy, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\nimport { FocusMonitor, _IdGenerator } from '@angular/cdk/a11y';\nimport { _CdkPrivateStyleLoader } from '@angular/cdk/private';\nimport { _ as _animationsDisabled } from './animation-DfMFjxHu.mjs';\nimport { _ as _StructuralStylesLoader } from './structural-styles-CObeNzjn.mjs';\nimport { M as MatRipple } from './ripple-BYgV4oZC.mjs';\nimport { _ as _MatInternalFormField } from './internal-form-field-D5iFxU6d.mjs';\nimport { M as MatCommonModule } from './common-module-cKSwHniA.mjs';\nimport '@angular/cdk/layout';\nimport '@angular/cdk/platform';\nimport '@angular/cdk/coercion';\nimport '@angular/cdk/bidi';\n\n/** Injection token to be used to override the default options for `mat-slide-toggle`. */\nconst _c0 = [\"switch\"];\nconst _c1 = [\"*\"];\nfunction MatSlideToggle_Conditional_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 10);\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(1, \"svg\", 12);\n    i0.ɵɵelement(2, \"path\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"svg\", 14);\n    i0.ɵɵelement(4, \"path\", 15);\n    i0.ɵɵelementEnd()();\n  }\n}\nconst MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = /*#__PURE__*/new InjectionToken('mat-slide-toggle-default-options', {\n  providedIn: 'root',\n  factory: () => ({\n    disableToggleValue: false,\n    hideIcon: false,\n    disabledInteractive: false\n  })\n});\n\n/** Change event object emitted by a slide toggle. */\nclass MatSlideToggleChange {\n  source;\n  checked;\n  constructor(/** The source slide toggle of the event. */\n  source, /** The new `checked` value of the slide toggle. */\n  checked) {\n    this.source = source;\n    this.checked = checked;\n  }\n}\nlet MatSlideToggle = /*#__PURE__*/(() => {\n  class MatSlideToggle {\n    _elementRef = inject(ElementRef);\n    _focusMonitor = inject(FocusMonitor);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    defaults = inject(MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS);\n    _onChange = _ => {};\n    _onTouched = () => {};\n    _validatorOnChange = () => {};\n    _uniqueId;\n    _checked = false;\n    _createChangeEvent(isChecked) {\n      return new MatSlideToggleChange(this, isChecked);\n    }\n    /** Unique ID for the label element. */\n    _labelId;\n    /** Returns the unique id for the visual hidden button. */\n    get buttonId() {\n      return `${this.id || this._uniqueId}-button`;\n    }\n    /** Reference to the MDC switch element. */\n    _switchElement;\n    /** Focuses the slide-toggle. */\n    focus() {\n      this._switchElement.nativeElement.focus();\n    }\n    /** Whether noop animations are enabled. */\n    _noopAnimations = _animationsDisabled();\n    /** Whether the slide toggle is currently focused. */\n    _focused;\n    /** Name value will be applied to the input element if present. */\n    name = null;\n    /** A unique id for the slide-toggle input. If none is supplied, it will be auto-generated. */\n    id;\n    /** Whether the label should appear after or before the slide-toggle. Defaults to 'after'. */\n    labelPosition = 'after';\n    /** Used to set the aria-label attribute on the underlying input element. */\n    ariaLabel = null;\n    /** Used to set the aria-labelledby attribute on the underlying input element. */\n    ariaLabelledby = null;\n    /** Used to set the aria-describedby attribute on the underlying input element. */\n    ariaDescribedby;\n    /** Whether the slide-toggle is required. */\n    required;\n    // TODO(crisbeto): this should be a ThemePalette, but some internal apps were abusing\n    // the lack of type checking previously and assigning random strings.\n    /**\n     * Theme color of the slide toggle. This API is supported in M2 themes only,\n     * it has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/slide-toggle/styling.\n     *\n     * For information on applying color variants in M3, see\n     * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n     */\n    color;\n    /** Whether the slide toggle is disabled. */\n    disabled = false;\n    /** Whether the slide toggle has a ripple. */\n    disableRipple = false;\n    /** Tabindex of slide toggle. */\n    tabIndex = 0;\n    /** Whether the slide-toggle element is checked or not. */\n    get checked() {\n      return this._checked;\n    }\n    set checked(value) {\n      this._checked = value;\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Whether to hide the icon inside of the slide toggle. */\n    hideIcon;\n    /** Whether the slide toggle should remain interactive when it is disabled. */\n    disabledInteractive;\n    /** An event will be dispatched each time the slide-toggle changes its value. */\n    change = new EventEmitter();\n    /**\n     * An event will be dispatched each time the slide-toggle input is toggled.\n     * This event is always emitted when the user toggles the slide toggle, but this does not mean\n     * the slide toggle's value has changed.\n     */\n    toggleChange = new EventEmitter();\n    /** Returns the unique id for the visual hidden input. */\n    get inputId() {\n      return `${this.id || this._uniqueId}-input`;\n    }\n    constructor() {\n      inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n      const tabIndex = inject(new HostAttributeToken('tabindex'), {\n        optional: true\n      });\n      const defaults = this.defaults;\n      this.tabIndex = tabIndex == null ? 0 : parseInt(tabIndex) || 0;\n      this.color = defaults.color || 'accent';\n      this.id = this._uniqueId = inject(_IdGenerator).getId('mat-mdc-slide-toggle-');\n      this.hideIcon = defaults.hideIcon ?? false;\n      this.disabledInteractive = defaults.disabledInteractive ?? false;\n      this._labelId = this._uniqueId + '-label';\n    }\n    ngAfterContentInit() {\n      this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n        if (focusOrigin === 'keyboard' || focusOrigin === 'program') {\n          this._focused = true;\n          this._changeDetectorRef.markForCheck();\n        } else if (!focusOrigin) {\n          // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n          // Angular does not expect events to be raised during change detection, so any state\n          // change (such as a form control's ng-touched) will cause a changed-after-checked error.\n          // See https://github.com/angular/angular/issues/17793. To work around this, we defer\n          // telling the form control it has been touched until the next tick.\n          Promise.resolve().then(() => {\n            this._focused = false;\n            this._onTouched();\n            this._changeDetectorRef.markForCheck();\n          });\n        }\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes['required']) {\n        this._validatorOnChange();\n      }\n    }\n    ngOnDestroy() {\n      this._focusMonitor.stopMonitoring(this._elementRef);\n    }\n    /** Implemented as part of ControlValueAccessor. */\n    writeValue(value) {\n      this.checked = !!value;\n    }\n    /** Implemented as part of ControlValueAccessor. */\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    /** Implemented as part of ControlValueAccessor. */\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    /** Implemented as a part of Validator. */\n    validate(control) {\n      return this.required && control.value !== true ? {\n        'required': true\n      } : null;\n    }\n    /** Implemented as a part of Validator. */\n    registerOnValidatorChange(fn) {\n      this._validatorOnChange = fn;\n    }\n    /** Implemented as a part of ControlValueAccessor. */\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Toggles the checked state of the slide-toggle. */\n    toggle() {\n      this.checked = !this.checked;\n      this._onChange(this.checked);\n    }\n    /**\n     * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n     */\n    _emitChangeEvent() {\n      this._onChange(this.checked);\n      this.change.emit(this._createChangeEvent(this.checked));\n    }\n    /** Method being called whenever the underlying button is clicked. */\n    _handleClick() {\n      if (!this.disabled) {\n        this.toggleChange.emit();\n        if (!this.defaults.disableToggleValue) {\n          this.checked = !this.checked;\n          this._onChange(this.checked);\n          this.change.emit(new MatSlideToggleChange(this, this.checked));\n        }\n      }\n    }\n    _getAriaLabelledBy() {\n      if (this.ariaLabelledby) {\n        return this.ariaLabelledby;\n      }\n      // Even though we have a `label` element with a `for` pointing to the button, we need the\n      // `aria-labelledby`, because the button gets flagged as not having a label by tools like axe.\n      return this.ariaLabel ? null : this._labelId;\n    }\n    static ɵfac = function MatSlideToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSlideToggle)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatSlideToggle,\n      selectors: [[\"mat-slide-toggle\"]],\n      viewQuery: function MatSlideToggle_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._switchElement = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mat-mdc-slide-toggle\"],\n      hostVars: 13,\n      hostBindings: function MatSlideToggle_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"id\", ctx.id);\n          i0.ɵɵattribute(\"tabindex\", null)(\"aria-label\", null)(\"name\", null)(\"aria-labelledby\", null);\n          i0.ɵɵclassMap(ctx.color ? \"mat-\" + ctx.color : \"\");\n          i0.ɵɵclassProp(\"mat-mdc-slide-toggle-focused\", ctx._focused)(\"mat-mdc-slide-toggle-checked\", ctx.checked)(\"_mat-animation-noopable\", ctx._noopAnimations);\n        }\n      },\n      inputs: {\n        name: \"name\",\n        id: \"id\",\n        labelPosition: \"labelPosition\",\n        ariaLabel: [0, \"aria-label\", \"ariaLabel\"],\n        ariaLabelledby: [0, \"aria-labelledby\", \"ariaLabelledby\"],\n        ariaDescribedby: [0, \"aria-describedby\", \"ariaDescribedby\"],\n        required: [2, \"required\", \"required\", booleanAttribute],\n        color: \"color\",\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        disableRipple: [2, \"disableRipple\", \"disableRipple\", booleanAttribute],\n        tabIndex: [2, \"tabIndex\", \"tabIndex\", value => value == null ? 0 : numberAttribute(value)],\n        checked: [2, \"checked\", \"checked\", booleanAttribute],\n        hideIcon: [2, \"hideIcon\", \"hideIcon\", booleanAttribute],\n        disabledInteractive: [2, \"disabledInteractive\", \"disabledInteractive\", booleanAttribute]\n      },\n      outputs: {\n        change: \"change\",\n        toggleChange: \"toggleChange\"\n      },\n      exportAs: [\"matSlideToggle\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(() => MatSlideToggle),\n        multi: true\n      }, {\n        provide: NG_VALIDATORS,\n        useExisting: MatSlideToggle,\n        multi: true\n      }]), i0.ɵɵNgOnChangesFeature],\n      ngContentSelectors: _c1,\n      decls: 13,\n      vars: 27,\n      consts: [[\"switch\", \"\"], [\"mat-internal-form-field\", \"\", 3, \"labelPosition\"], [\"role\", \"switch\", \"type\", \"button\", 1, \"mdc-switch\", 3, \"click\", \"tabIndex\", \"disabled\"], [1, \"mdc-switch__track\"], [1, \"mdc-switch__handle-track\"], [1, \"mdc-switch__handle\"], [1, \"mdc-switch__shadow\"], [1, \"mdc-elevation-overlay\"], [1, \"mdc-switch__ripple\"], [\"mat-ripple\", \"\", 1, \"mat-mdc-slide-toggle-ripple\", \"mat-focus-indicator\", 3, \"matRippleTrigger\", \"matRippleDisabled\", \"matRippleCentered\"], [1, \"mdc-switch__icons\"], [1, \"mdc-label\", 3, \"click\", \"for\"], [\"viewBox\", \"0 0 24 24\", \"aria-hidden\", \"true\", 1, \"mdc-switch__icon\", \"mdc-switch__icon--on\"], [\"d\", \"M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z\"], [\"viewBox\", \"0 0 24 24\", \"aria-hidden\", \"true\", 1, \"mdc-switch__icon\", \"mdc-switch__icon--off\"], [\"d\", \"M20 13H4v-2h16v2z\"]],\n      template: function MatSlideToggle_Template(rf, ctx) {\n        if (rf & 1) {\n          const _r1 = i0.ɵɵgetCurrentView();\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", 1)(1, \"button\", 2, 0);\n          i0.ɵɵlistener(\"click\", function MatSlideToggle_Template_button_click_1_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx._handleClick());\n          });\n          i0.ɵɵelement(3, \"span\", 3);\n          i0.ɵɵelementStart(4, \"span\", 4)(5, \"span\", 5)(6, \"span\", 6);\n          i0.ɵɵelement(7, \"span\", 7);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(8, \"span\", 8);\n          i0.ɵɵelement(9, \"span\", 9);\n          i0.ɵɵelementEnd();\n          i0.ɵɵconditionalCreate(10, MatSlideToggle_Conditional_10_Template, 5, 0, \"span\", 10);\n          i0.ɵɵelementEnd()()();\n          i0.ɵɵelementStart(11, \"label\", 11);\n          i0.ɵɵlistener(\"click\", function MatSlideToggle_Template_label_click_11_listener($event) {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView($event.stopPropagation());\n          });\n          i0.ɵɵprojection(12);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          const switch_r2 = i0.ɵɵreference(2);\n          i0.ɵɵproperty(\"labelPosition\", ctx.labelPosition);\n          i0.ɵɵadvance();\n          i0.ɵɵclassProp(\"mdc-switch--selected\", ctx.checked)(\"mdc-switch--unselected\", !ctx.checked)(\"mdc-switch--checked\", ctx.checked)(\"mdc-switch--disabled\", ctx.disabled)(\"mat-mdc-slide-toggle-disabled-interactive\", ctx.disabledInteractive);\n          i0.ɵɵproperty(\"tabIndex\", ctx.disabled && !ctx.disabledInteractive ? -1 : ctx.tabIndex)(\"disabled\", ctx.disabled && !ctx.disabledInteractive);\n          i0.ɵɵattribute(\"id\", ctx.buttonId)(\"name\", ctx.name)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx._getAriaLabelledBy())(\"aria-describedby\", ctx.ariaDescribedby)(\"aria-required\", ctx.required || null)(\"aria-checked\", ctx.checked)(\"aria-disabled\", ctx.disabled && ctx.disabledInteractive ? \"true\" : null);\n          i0.ɵɵadvance(8);\n          i0.ɵɵproperty(\"matRippleTrigger\", switch_r2)(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleCentered\", true);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(!ctx.hideIcon ? 10 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"for\", ctx.buttonId);\n          i0.ɵɵattribute(\"id\", ctx._labelId);\n        }\n      },\n      dependencies: [MatRipple, _MatInternalFormField],\n      styles: [\".mdc-switch{align-items:center;background:none;border:none;cursor:pointer;display:inline-flex;flex-shrink:0;margin:0;outline:none;overflow:visible;padding:0;position:relative;width:var(--mat-slide-toggle-track-width, 52px)}.mdc-switch.mdc-switch--disabled{cursor:default;pointer-events:none}.mdc-switch.mat-mdc-slide-toggle-disabled-interactive{pointer-events:auto}.mdc-switch__track{overflow:hidden;position:relative;width:100%;height:var(--mat-slide-toggle-track-height, 32px);border-radius:var(--mat-slide-toggle-track-shape, var(--mat-sys-corner-full))}.mdc-switch--disabled.mdc-switch .mdc-switch__track{opacity:var(--mat-slide-toggle-disabled-track-opacity, 0.12)}.mdc-switch__track::before,.mdc-switch__track::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:\\\"\\\";height:100%;left:0;position:absolute;width:100%;border-width:var(--mat-slide-toggle-track-outline-width, 2px);border-color:var(--mat-slide-toggle-track-outline-color, var(--mat-sys-outline))}.mdc-switch--selected .mdc-switch__track::before,.mdc-switch--selected .mdc-switch__track::after{border-width:var(--mat-slide-toggle-selected-track-outline-width, 2px);border-color:var(--mat-slide-toggle-selected-track-outline-color, transparent)}.mdc-switch--disabled .mdc-switch__track::before,.mdc-switch--disabled .mdc-switch__track::after{border-width:var(--mat-slide-toggle-disabled-unselected-track-outline-width, 2px);border-color:var(--mat-slide-toggle-disabled-unselected-track-outline-color, var(--mat-sys-on-surface))}@media(forced-colors: active){.mdc-switch__track{border-color:currentColor}}.mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:translateX(0);background:var(--mat-slide-toggle-unselected-track-color, var(--mat-sys-surface-variant))}.mdc-switch--selected .mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch--selected .mdc-switch__track::before{transform:translateX(-100%)}.mdc-switch--selected .mdc-switch__track::before{opacity:var(--mat-slide-toggle-hidden-track-opacity, 0);transition:var(--mat-slide-toggle-hidden-track-transition, opacity 75ms)}.mdc-switch--unselected .mdc-switch__track::before{opacity:var(--mat-slide-toggle-visible-track-opacity, 1);transition:var(--mat-slide-toggle-visible-track-transition, opacity 75ms)}.mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::before{background:var(--mat-slide-toggle-unselected-hover-track-color, var(--mat-sys-surface-variant))}.mdc-switch:enabled:focus:not(:active) .mdc-switch__track::before{background:var(--mat-slide-toggle-unselected-focus-track-color, var(--mat-sys-surface-variant))}.mdc-switch:enabled:active .mdc-switch__track::before{background:var(--mat-slide-toggle-unselected-pressed-track-color, var(--mat-sys-surface-variant))}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:hover:not(:focus):not(:active) .mdc-switch__track::before,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:focus:not(:active) .mdc-switch__track::before,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:active .mdc-switch__track::before,.mdc-switch.mdc-switch--disabled .mdc-switch__track::before{background:var(--mat-slide-toggle-disabled-unselected-track-color, var(--mat-sys-surface-variant))}.mdc-switch__track::after{transform:translateX(-100%);background:var(--mat-slide-toggle-selected-track-color, var(--mat-sys-primary))}[dir=rtl] .mdc-switch__track::after{transform:translateX(100%)}.mdc-switch--selected .mdc-switch__track::after{transform:translateX(0)}.mdc-switch--selected .mdc-switch__track::after{opacity:var(--mat-slide-toggle-visible-track-opacity, 1);transition:var(--mat-slide-toggle-visible-track-transition, opacity 75ms)}.mdc-switch--unselected .mdc-switch__track::after{opacity:var(--mat-slide-toggle-hidden-track-opacity, 0);transition:var(--mat-slide-toggle-hidden-track-transition, opacity 75ms)}.mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::after{background:var(--mat-slide-toggle-selected-hover-track-color, var(--mat-sys-primary))}.mdc-switch:enabled:focus:not(:active) .mdc-switch__track::after{background:var(--mat-slide-toggle-selected-focus-track-color, var(--mat-sys-primary))}.mdc-switch:enabled:active .mdc-switch__track::after{background:var(--mat-slide-toggle-selected-pressed-track-color, var(--mat-sys-primary))}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:hover:not(:focus):not(:active) .mdc-switch__track::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:focus:not(:active) .mdc-switch__track::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:active .mdc-switch__track::after,.mdc-switch.mdc-switch--disabled .mdc-switch__track::after{background:var(--mat-slide-toggle-disabled-selected-track-color, var(--mat-sys-on-surface))}.mdc-switch__handle-track{height:100%;pointer-events:none;position:absolute;top:0;transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);left:0;right:auto;transform:translateX(0);width:calc(100% - var(--mat-slide-toggle-handle-width))}[dir=rtl] .mdc-switch__handle-track{left:auto;right:0}.mdc-switch--selected .mdc-switch__handle-track{transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch__handle-track{transform:translateX(-100%)}.mdc-switch__handle{display:flex;pointer-events:auto;position:absolute;top:50%;transform:translateY(-50%);left:0;right:auto;transition:width 75ms cubic-bezier(0.4, 0, 0.2, 1),height 75ms cubic-bezier(0.4, 0, 0.2, 1),margin 75ms cubic-bezier(0.4, 0, 0.2, 1);width:var(--mat-slide-toggle-handle-width);height:var(--mat-slide-toggle-handle-height);border-radius:var(--mat-slide-toggle-handle-shape, var(--mat-sys-corner-full))}[dir=rtl] .mdc-switch__handle{left:auto;right:0}.mat-mdc-slide-toggle .mdc-switch--unselected .mdc-switch__handle{width:var(--mat-slide-toggle-unselected-handle-size, 16px);height:var(--mat-slide-toggle-unselected-handle-size, 16px);margin:var(--mat-slide-toggle-unselected-handle-horizontal-margin, 0 8px)}.mat-mdc-slide-toggle .mdc-switch--unselected .mdc-switch__handle:has(.mdc-switch__icons){margin:var(--mat-slide-toggle-unselected-with-icon-handle-horizontal-margin, 0 4px)}.mat-mdc-slide-toggle .mdc-switch--selected .mdc-switch__handle{width:var(--mat-slide-toggle-selected-handle-size, 24px);height:var(--mat-slide-toggle-selected-handle-size, 24px);margin:var(--mat-slide-toggle-selected-handle-horizontal-margin, 0 24px)}.mat-mdc-slide-toggle .mdc-switch--selected .mdc-switch__handle:has(.mdc-switch__icons){margin:var(--mat-slide-toggle-selected-with-icon-handle-horizontal-margin, 0 24px)}.mat-mdc-slide-toggle .mdc-switch__handle:has(.mdc-switch__icons){width:var(--mat-slide-toggle-with-icon-handle-size, 24px);height:var(--mat-slide-toggle-with-icon-handle-size, 24px)}.mat-mdc-slide-toggle .mdc-switch:active:not(.mdc-switch--disabled) .mdc-switch__handle{width:var(--mat-slide-toggle-pressed-handle-size, 28px);height:var(--mat-slide-toggle-pressed-handle-size, 28px)}.mat-mdc-slide-toggle .mdc-switch--selected:active:not(.mdc-switch--disabled) .mdc-switch__handle{margin:var(--mat-slide-toggle-selected-pressed-handle-horizontal-margin, 0 22px)}.mat-mdc-slide-toggle .mdc-switch--unselected:active:not(.mdc-switch--disabled) .mdc-switch__handle{margin:var(--mat-slide-toggle-unselected-pressed-handle-horizontal-margin, 0 2px)}.mdc-switch--disabled.mdc-switch--selected .mdc-switch__handle::after{opacity:var(--mat-slide-toggle-disabled-selected-handle-opacity, 1)}.mdc-switch--disabled.mdc-switch--unselected .mdc-switch__handle::after{opacity:var(--mat-slide-toggle-disabled-unselected-handle-opacity, 0.38)}.mdc-switch__handle::before,.mdc-switch__handle::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:\\\"\\\";width:100%;height:100%;left:0;position:absolute;top:0;transition:background-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1),border-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);z-index:-1}@media(forced-colors: active){.mdc-switch__handle::before,.mdc-switch__handle::after{border-color:currentColor}}.mdc-switch--selected:enabled .mdc-switch__handle::after{background:var(--mat-slide-toggle-selected-handle-color, var(--mat-sys-on-primary))}.mdc-switch--selected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mat-slide-toggle-selected-hover-handle-color, var(--mat-sys-primary-container))}.mdc-switch--selected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mat-slide-toggle-selected-focus-handle-color, var(--mat-sys-primary-container))}.mdc-switch--selected:enabled:active .mdc-switch__handle::after{background:var(--mat-slide-toggle-selected-pressed-handle-color, var(--mat-sys-primary-container))}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled.mdc-switch--selected:hover:not(:focus):not(:active) .mdc-switch__handle::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled.mdc-switch--selected:focus:not(:active) .mdc-switch__handle::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled.mdc-switch--selected:active .mdc-switch__handle::after,.mdc-switch--selected.mdc-switch--disabled .mdc-switch__handle::after{background:var(--mat-slide-toggle-disabled-selected-handle-color, var(--mat-sys-surface))}.mdc-switch--unselected:enabled .mdc-switch__handle::after{background:var(--mat-slide-toggle-unselected-handle-color, var(--mat-sys-outline))}.mdc-switch--unselected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mat-slide-toggle-unselected-hover-handle-color, var(--mat-sys-on-surface-variant))}.mdc-switch--unselected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mat-slide-toggle-unselected-focus-handle-color, var(--mat-sys-on-surface-variant))}.mdc-switch--unselected:enabled:active .mdc-switch__handle::after{background:var(--mat-slide-toggle-unselected-pressed-handle-color, var(--mat-sys-on-surface-variant))}.mdc-switch--unselected.mdc-switch--disabled .mdc-switch__handle::after{background:var(--mat-slide-toggle-disabled-unselected-handle-color, var(--mat-sys-on-surface))}.mdc-switch__handle::before{background:var(--mat-slide-toggle-handle-surface-color)}.mdc-switch__shadow{border-radius:inherit;bottom:0;left:0;position:absolute;right:0;top:0}.mdc-switch:enabled .mdc-switch__shadow{box-shadow:var(--mat-slide-toggle-handle-elevation-shadow)}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:hover:not(:focus):not(:active) .mdc-switch__shadow,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:focus:not(:active) .mdc-switch__shadow,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:active .mdc-switch__shadow,.mdc-switch.mdc-switch--disabled .mdc-switch__shadow{box-shadow:var(--mat-slide-toggle-disabled-handle-elevation-shadow)}.mdc-switch__ripple{left:50%;position:absolute;top:50%;transform:translate(-50%, -50%);z-index:-1;width:var(--mat-slide-toggle-state-layer-size, 40px);height:var(--mat-slide-toggle-state-layer-size, 40px)}.mdc-switch__ripple::after{content:\\\"\\\";opacity:0}.mdc-switch--disabled .mdc-switch__ripple::after{display:none}.mat-mdc-slide-toggle-disabled-interactive .mdc-switch__ripple::after{display:block}.mdc-switch:hover .mdc-switch__ripple::after{transition:75ms opacity cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:enabled:focus .mdc-switch__ripple::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:enabled:active .mdc-switch__ripple::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:enabled:hover:not(:focus) .mdc-switch__ripple::after,.mdc-switch--unselected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background:var(--mat-slide-toggle-unselected-hover-state-layer-color, var(--mat-sys-on-surface));opacity:var(--mat-slide-toggle-unselected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mdc-switch--unselected:enabled:focus .mdc-switch__ripple::after{background:var(--mat-slide-toggle-unselected-focus-state-layer-color, var(--mat-sys-on-surface));opacity:var(--mat-slide-toggle-unselected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mdc-switch--unselected:enabled:active .mdc-switch__ripple::after{background:var(--mat-slide-toggle-unselected-pressed-state-layer-color, var(--mat-sys-on-surface));opacity:var(--mat-slide-toggle-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));transition:opacity 75ms linear}.mdc-switch--selected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background:var(--mat-slide-toggle-selected-hover-state-layer-color, var(--mat-sys-primary));opacity:var(--mat-slide-toggle-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mdc-switch--selected:enabled:focus .mdc-switch__ripple::after{background:var(--mat-slide-toggle-selected-focus-state-layer-color, var(--mat-sys-primary));opacity:var(--mat-slide-toggle-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mdc-switch--selected:enabled:active .mdc-switch__ripple::after{background:var(--mat-slide-toggle-selected-pressed-state-layer-color, var(--mat-sys-primary));opacity:var(--mat-slide-toggle-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));transition:opacity 75ms linear}.mdc-switch__icons{position:relative;height:100%;width:100%;z-index:1;transform:translateZ(0)}.mdc-switch--disabled.mdc-switch--unselected .mdc-switch__icons{opacity:var(--mat-slide-toggle-disabled-unselected-icon-opacity, 0.38)}.mdc-switch--disabled.mdc-switch--selected .mdc-switch__icons{opacity:var(--mat-slide-toggle-disabled-selected-icon-opacity, 0.38)}.mdc-switch__icon{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0;opacity:0;transition:opacity 30ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-switch--unselected .mdc-switch__icon{width:var(--mat-slide-toggle-unselected-icon-size, 16px);height:var(--mat-slide-toggle-unselected-icon-size, 16px);fill:var(--mat-slide-toggle-unselected-icon-color, var(--mat-sys-surface-variant))}.mdc-switch--unselected.mdc-switch--disabled .mdc-switch__icon{fill:var(--mat-slide-toggle-disabled-unselected-icon-color, var(--mat-sys-surface-variant))}.mdc-switch--selected .mdc-switch__icon{width:var(--mat-slide-toggle-selected-icon-size, 16px);height:var(--mat-slide-toggle-selected-icon-size, 16px);fill:var(--mat-slide-toggle-selected-icon-color, var(--mat-sys-on-primary-container))}.mdc-switch--selected.mdc-switch--disabled .mdc-switch__icon{fill:var(--mat-slide-toggle-disabled-selected-icon-color, var(--mat-sys-on-surface))}.mdc-switch--selected .mdc-switch__icon--on,.mdc-switch--unselected .mdc-switch__icon--off{opacity:1;transition:opacity 45ms 30ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle{-webkit-user-select:none;user-select:none;display:inline-block;-webkit-tap-highlight-color:rgba(0,0,0,0);outline:0}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple,.mat-mdc-slide-toggle .mdc-switch__ripple::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple:not(:empty),.mat-mdc-slide-toggle .mdc-switch__ripple::after:not(:empty){transform:translateZ(0)}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mat-focus-indicator::before{content:\\\"\\\"}.mat-mdc-slide-toggle .mat-internal-form-field{color:var(--mat-slide-toggle-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-slide-toggle-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-slide-toggle-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-slide-toggle-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-slide-toggle-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-slide-toggle-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-slide-toggle .mat-ripple-element{opacity:.12}.mat-mdc-slide-toggle .mat-focus-indicator::before{border-radius:50%}.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle-track,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__icon,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::after,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::after{transition:none}.mat-mdc-slide-toggle .mdc-switch:enabled+.mdc-label{cursor:pointer}.mat-mdc-slide-toggle .mdc-switch--disabled+label{color:var(--mat-slide-toggle-disabled-label-text-color)}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatSlideToggle;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatSlideToggleModule = /*#__PURE__*/(() => {\n  class MatSlideToggleModule {\n    static ɵfac = function MatSlideToggleModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSlideToggleModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatSlideToggleModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [MatSlideToggle, MatCommonModule, MatCommonModule]\n    });\n  }\n  return MatSlideToggleModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS, MatSlideToggle, MatSlideToggleChange, MatSlideToggleModule };\n","// Compute what scrolling needs to be done on required scrolling boxes for target to be in view\n\n// The type names here are named after the spec to make it easier to find more information around what they mean:\n// To reduce churn and reduce things that need be maintained things from the official TS DOM library is used here\n// https://drafts.csswg.org/cssom-view/\n\n// For a definition on what is \"block flow direction\" exactly, check this: https://drafts.csswg.org/css-writing-modes-4/#block-flow-direction\n\n/**\n * This new option is tracked in this PR, which is the most likely candidate at the time: https://github.com/w3c/csswg-drafts/pull/1805\n * @public\n */\nexport type ScrollMode = 'always' | 'if-needed'\n\n/** @public */\nexport interface Options {\n  /**\n   * Control the logical scroll position on the y-axis. The spec states that the `block` direction is related to the [writing-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode), but this is not implemented yet in this library.\n   * This means that `block: 'start'` aligns to the top edge and `block: 'end'` to the bottom.\n   * @defaultValue 'center'\n   */\n  block?: ScrollLogicalPosition\n  /**\n   * Like `block` this is affected by the [writing-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode). In left-to-right pages `inline: 'start'` will align to the left edge. In right-to-left it should be flipped. This will be supported in a future release.\n   * @defaultValue 'nearest'\n   */\n  inline?: ScrollLogicalPosition\n  /**\n   * This is a proposed addition to the spec that you can track here: https://github.com/w3c/csswg-drafts/pull/5677\n   *\n   * This library will be updated to reflect any changes to the spec and will provide a migration path.\n   * To be backwards compatible with `Element.scrollIntoViewIfNeeded` if something is not 100% visible it will count as \"needs scrolling\". If you need a different visibility ratio your best option would be to implement an [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).\n   * @defaultValue 'always'\n   */\n  scrollMode?: ScrollMode\n  /**\n   * By default there is no boundary. All the parent elements of your target is checked until it reaches the viewport ([`document.scrollingElement`](https://developer.mozilla.org/en-US/docs/Web/API/document/scrollingElement)) when calculating layout and what to scroll.\n   * By passing a boundary you can short-circuit this loop depending on your needs:\n   * \n   * - Prevent the browser window from scrolling.\n   * - Scroll elements into view in a list, without scrolling container elements.\n   * \n   * You can also pass a function to do more dynamic checks to override the scroll scoping:\n   * \n   * ```js\n   * let actions = compute(target, {\n   *   boundary: (parent) => {\n   *     // By default `overflow: hidden` elements are allowed, only `overflow: visible | clip` is skipped as\n   *     // this is required by the CSSOM spec\n   *     if (getComputedStyle(parent)['overflow'] === 'hidden') {\n   *       return false\n   *     }\n\n   *     return true\n   *   },\n   * })\n   * ```\n   * @defaultValue null\n   */\n  boundary?: Element | ((parent: Element) => boolean) | null\n  /**\n   * New option that skips auto-scrolling all nodes with overflow: hidden set\n   * See FF implementation: https://hg.mozilla.org/integration/fx-team/rev/c48c3ec05012#l7.18\n   * @defaultValue false\n   * @public\n   */\n  skipOverflowHiddenElements?: boolean\n}\n\n/** @public */\nexport interface ScrollAction {\n  el: Element\n  top: number\n  left: number\n}\n\n// @TODO better shadowdom test, 11 = document fragment\nconst isElement = (el: any): el is Element =>\n  typeof el === 'object' && el != null && el.nodeType === 1\n\nconst canOverflow = (\n  overflow: string | null,\n  skipOverflowHiddenElements?: boolean\n) => {\n  if (skipOverflowHiddenElements && overflow === 'hidden') {\n    return false\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip'\n}\n\nconst getFrameElement = (el: Element) => {\n  if (!el.ownerDocument || !el.ownerDocument.defaultView) {\n    return null\n  }\n\n  try {\n    return el.ownerDocument.defaultView.frameElement\n  } catch (e) {\n    return null\n  }\n}\n\nconst isHiddenByFrame = (el: Element): boolean => {\n  const frame = getFrameElement(el)\n  if (!frame) {\n    return false\n  }\n\n  return (\n    frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth\n  )\n}\n\nconst isScrollable = (el: Element, skipOverflowHiddenElements?: boolean) => {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    const style = getComputedStyle(el, null)\n    return (\n      canOverflow(style.overflowY, skipOverflowHiddenElements) ||\n      canOverflow(style.overflowX, skipOverflowHiddenElements) ||\n      isHiddenByFrame(el)\n    )\n  }\n\n  return false\n}\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst alignNearest = (\n  scrollingEdgeStart: number,\n  scrollingEdgeEnd: number,\n  scrollingSize: number,\n  scrollingBorderStart: number,\n  scrollingBorderEnd: number,\n  elementEdgeStart: number,\n  elementEdgeEnd: number,\n  elementSize: number\n) => {\n  /**\n   * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓\n   *          │  │\n   *        ┃ │  │ ┃        do nothing\n   *          │  │\n   *        ┗━│━━│━┛\n   *          └──┘\n   *\n   *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n   *\n   *    ┏ ━ ━ ━ ━ ┓\n   *   ┌───────────┐\n   *   │┃         ┃│        do nothing\n   *   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛\n   */\n  if (\n    (elementEdgeStart < scrollingEdgeStart &&\n      elementEdgeEnd > scrollingEdgeEnd) ||\n    (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n  ) {\n    return 0\n  }\n\n  /**\n   * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓         ┏━┌━━┐━┓\n   *          └──┘             │  │\n   *  from  ┃      ┃     to  ┃ └──┘ ┃\n   *\n   *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n   *\n   * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n   *                           │  │\n   *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n   *          │  │             │  │\n   *        ┗━│━━│━┛         ┗━│━━│━┛\n   *          │  │             └──┘\n   *          │  │\n   *          └──┘\n   *\n   * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───┐                 ┌───┐\n   *  │ ┃ │       ┃         ┃   │     ┃\n   *  └───┘                 └───┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *        ┌───────────┐   ┌───────────┐\n   *    ┃   │     ┃     │   ┃         ┃ │\n   *        └───────────┘   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   */\n  if (\n    (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n    (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n  ) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart\n  }\n\n  /**\n   * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n   *\n   *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n   *          ┌──┐             │  │\n   *        ┗━│━━│━┛         ┗━└━━┘━┛\n   *          └──┘\n   *\n   * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n   *\n   *          ┌──┐\n   *          │  │\n   *          │  │             ┌──┐\n   *        ┏━│━━│━┓         ┏━│━━│━┓\n   *          │  │             │  │\n   *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n   *                           │  │\n   *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n   *\n   * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───────────┐           ┌───────────┐\n   *  │     ┃     │   ┃       │ ┃         ┃\n   *  └───────────┘           └───────────┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *                ┌───┐             ┌───┐\n   *        ┃       │ ┃ │       ┃     │   ┃\n   *                └───┘             └───┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   */\n  if (\n    (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n    (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n  ) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd\n  }\n\n  return 0\n}\n\nconst getParentElement = (element: Node): Element | null => {\n  const parent = element.parentElement\n  if (parent == null) {\n    return (element.getRootNode() as ShadowRoot).host || null\n  }\n  return parent\n}\n\nconst getScrollMargins = (target: Element) => {\n  const computedStyle = window.getComputedStyle(target)\n  return {\n    top: parseFloat(computedStyle.scrollMarginTop) || 0,\n    right: parseFloat(computedStyle.scrollMarginRight) || 0,\n    bottom: parseFloat(computedStyle.scrollMarginBottom) || 0,\n    left: parseFloat(computedStyle.scrollMarginLeft) || 0,\n  }\n}\n\n/** @public */\nexport const compute = (target: Element, options: Options): ScrollAction[] => {\n  if (typeof document === 'undefined') {\n    // If there's no DOM we assume it's not in a browser environment\n    return []\n  }\n\n  const { scrollMode, block, inline, boundary, skipOverflowHiddenElements } =\n    options\n  // Allow using a callback to check the boundary\n  // The default behavior is to check if the current target matches the boundary element or not\n  // If undefined it'll check that target is never undefined (can happen as we recurse up the tree)\n  const checkBoundary =\n    typeof boundary === 'function' ? boundary : (node: any) => node !== boundary\n\n  if (!isElement(target)) {\n    throw new TypeError('Invalid target')\n  }\n\n  // Used to handle the top most element that can be scrolled\n  const scrollingElement = document.scrollingElement || document.documentElement\n\n  // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n  const frames: Element[] = []\n  let cursor: Element | null = target\n  while (isElement(cursor) && checkBoundary(cursor)) {\n    // Move cursor to parent\n    cursor = getParentElement(cursor)\n\n    // Stop when we reach the viewport\n    if (cursor === scrollingElement) {\n      frames.push(cursor)\n      break\n    }\n\n    // Skip document.body if it's not the scrollingElement and documentElement isn't independently scrollable\n    if (\n      cursor != null &&\n      cursor === document.body &&\n      isScrollable(cursor) &&\n      !isScrollable(document.documentElement)\n    ) {\n      continue\n    }\n\n    // Now we check if the element is scrollable, this code only runs if the loop haven't already hit the viewport or a custom boundary\n    if (cursor != null && isScrollable(cursor, skipOverflowHiddenElements)) {\n      frames.push(cursor)\n    }\n  }\n\n  // Support pinch-zooming properly, making sure elements scroll into the visual viewport\n  // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height\n  // and viewport dimensions on window.innerWidth/Height\n  // https://www.quirksmode.org/mobile/viewports2.html\n  // https://bokand.github.io/viewport/index.html\n  const viewportWidth = window.visualViewport?.width ?? innerWidth\n  const viewportHeight = window.visualViewport?.height ?? innerHeight\n  const { scrollX, scrollY } = window\n\n  const {\n    height: targetHeight,\n    width: targetWidth,\n    top: targetTop,\n    right: targetRight,\n    bottom: targetBottom,\n    left: targetLeft,\n  } = target.getBoundingClientRect()\n  const {\n    top: marginTop,\n    right: marginRight,\n    bottom: marginBottom,\n    left: marginLeft,\n  } = getScrollMargins(target)\n\n  // These values mutate as we loop through and generate scroll coordinates\n  let targetBlock: number =\n    block === 'start' || block === 'nearest'\n      ? targetTop - marginTop\n      : block === 'end'\n      ? targetBottom + marginBottom\n      : targetTop + targetHeight / 2 - marginTop + marginBottom // block === 'center\n  let targetInline: number =\n    inline === 'center'\n      ? targetLeft + targetWidth / 2 - marginLeft + marginRight\n      : inline === 'end'\n      ? targetRight + marginRight\n      : targetLeft - marginLeft // inline === 'start || inline === 'nearest\n\n  // Collect new scroll positions\n  const computations: ScrollAction[] = []\n  // In chrome there's no longer a difference between caching the `frames.length` to a var or not, so we don't in this case (size > speed anyways)\n  for (let index = 0; index < frames.length; index++) {\n    const frame = frames[index]\n\n    // @TODO add a shouldScroll hook here that allows userland code to take control\n\n    const { height, width, top, right, bottom, left } =\n      frame.getBoundingClientRect()\n\n    // If the element is already visible we can end it here\n    // @TODO targetBlock and targetInline should be taken into account to be compliant with https://github.com/w3c/csswg-drafts/pull/1805/files#diff-3c17f0e43c20f8ecf89419d49e7ef5e0R1333\n    if (\n      scrollMode === 'if-needed' &&\n      targetTop >= 0 &&\n      targetLeft >= 0 &&\n      targetBottom <= viewportHeight &&\n      targetRight <= viewportWidth &&\n      // scrollingElement is added to the frames array even if it's not scrollable, in which case checking its bounds is not required\n      ((frame === scrollingElement && !isScrollable(frame)) ||\n        (targetTop >= top &&\n          targetBottom <= bottom &&\n          targetLeft >= left &&\n          targetRight <= right))\n    ) {\n      // Break the loop and return the computations for things that are not fully visible\n      return computations\n    }\n\n    const frameStyle = getComputedStyle(frame)\n    const borderLeft = parseInt(frameStyle.borderLeftWidth as string, 10)\n    const borderTop = parseInt(frameStyle.borderTopWidth as string, 10)\n    const borderRight = parseInt(frameStyle.borderRightWidth as string, 10)\n    const borderBottom = parseInt(frameStyle.borderBottomWidth as string, 10)\n\n    let blockScroll: number = 0\n    let inlineScroll: number = 0\n\n    // The property existance checks for offfset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here\n    // @TODO find out if the \"as HTMLElement\" overrides can be dropped\n    const scrollbarWidth =\n      'offsetWidth' in frame\n        ? (frame as HTMLElement).offsetWidth -\n          (frame as HTMLElement).clientWidth -\n          borderLeft -\n          borderRight\n        : 0\n    const scrollbarHeight =\n      'offsetHeight' in frame\n        ? (frame as HTMLElement).offsetHeight -\n          (frame as HTMLElement).clientHeight -\n          borderTop -\n          borderBottom\n        : 0\n\n    const scaleX =\n      'offsetWidth' in frame\n        ? (frame as HTMLElement).offsetWidth === 0\n          ? 0\n          : width / (frame as HTMLElement).offsetWidth\n        : 0\n    const scaleY =\n      'offsetHeight' in frame\n        ? (frame as HTMLElement).offsetHeight === 0\n          ? 0\n          : height / (frame as HTMLElement).offsetHeight\n        : 0\n\n    if (scrollingElement === frame) {\n      // Handle viewport logic (document.documentElement or document.body)\n\n      if (block === 'start') {\n        blockScroll = targetBlock\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          scrollY,\n          scrollY + viewportHeight,\n          viewportHeight,\n          borderTop,\n          borderBottom,\n          scrollY + targetBlock,\n          scrollY + targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - viewportHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(\n          scrollX,\n          scrollX + viewportWidth,\n          viewportWidth,\n          borderLeft,\n          borderRight,\n          scrollX + targetInline,\n          scrollX + targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      // Apply scroll position offsets and ensure they are within bounds\n      // @TODO add more test cases to cover this 100%\n      blockScroll = Math.max(0, blockScroll + scrollY)\n      inlineScroll = Math.max(0, inlineScroll + scrollX)\n    } else {\n      // Handle each scrolling frame that might exist between the target and the viewport\n      if (block === 'start') {\n        blockScroll = targetBlock - top - borderTop\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          top,\n          bottom,\n          height,\n          borderTop,\n          borderBottom + scrollbarHeight,\n          targetBlock,\n          targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        // block === 'center' is the default\n        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - left - borderLeft\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth\n      } else {\n        // inline === 'nearest' is the default\n        inlineScroll = alignNearest(\n          left,\n          right,\n          width,\n          borderLeft,\n          borderRight + scrollbarWidth,\n          targetInline,\n          targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      const { scrollLeft, scrollTop } = frame\n      // Ensure scroll coordinates are not out of bounds while applying scroll offsets\n      blockScroll =\n        scaleY === 0\n          ? 0\n          : Math.max(\n              0,\n              Math.min(\n                scrollTop + blockScroll / scaleY,\n                frame.scrollHeight - height / scaleY + scrollbarHeight\n              )\n            )\n      inlineScroll =\n        scaleX === 0\n          ? 0\n          : Math.max(\n              0,\n              Math.min(\n                scrollLeft + inlineScroll / scaleX,\n                frame.scrollWidth - width / scaleX + scrollbarWidth\n              )\n            )\n\n      // Cache the offset so that parent frames can scroll this into view correctly\n      targetBlock += scrollTop - blockScroll\n      targetInline += scrollLeft - inlineScroll\n    }\n\n    computations.push({ el: frame, top: blockScroll, left: inlineScroll })\n  }\n\n  return computations\n}\n","import * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, ViewEncapsulation, inject, NgZone, RendererFactory2, Injectable, ElementRef, EventEmitter, Directive, Output, Renderer2, DOCUMENT, booleanAttribute, Input, NgModule } from '@angular/core';\nimport { EMPTY, Subject } from 'rxjs';\nimport { P as Platform } from './platform-DNDzkVcI.mjs';\nimport { _ as _CdkPrivateStyleLoader } from './style-loader-B2sGQXxD.mjs';\nimport { a as coerceElement, c as coerceNumberProperty } from './element-x4z00URv.mjs';\nimport { auditTime } from 'rxjs/operators';\nimport '@angular/common';\n\n/** Component used to load the structural styles of the text field. */\nlet _CdkTextFieldStyleLoader = /*#__PURE__*/(() => {\n  class _CdkTextFieldStyleLoader {\n    static ɵfac = function _CdkTextFieldStyleLoader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _CdkTextFieldStyleLoader)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: _CdkTextFieldStyleLoader,\n      selectors: [[\"ng-component\"]],\n      hostAttrs: [\"cdk-text-field-style-loader\", \"\"],\n      decls: 0,\n      vars: 0,\n      template: function _CdkTextFieldStyleLoader_Template(rf, ctx) {},\n      styles: [\"textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0 !important;box-sizing:content-box !important;height:auto !important;overflow:hidden !important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0 !important;box-sizing:content-box !important;height:0 !important}@keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return _CdkTextFieldStyleLoader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Options to pass to the animationstart listener. */\nconst listenerOptions = {\n  passive: true\n};\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nlet AutofillMonitor = /*#__PURE__*/(() => {\n  class AutofillMonitor {\n    _platform = inject(Platform);\n    _ngZone = inject(NgZone);\n    _renderer = inject(RendererFactory2).createRenderer(null, null);\n    _styleLoader = inject(_CdkPrivateStyleLoader);\n    _monitoredElements = new Map();\n    constructor() {}\n    monitor(elementOrRef) {\n      if (!this._platform.isBrowser) {\n        return EMPTY;\n      }\n      this._styleLoader.load(_CdkTextFieldStyleLoader);\n      const element = coerceElement(elementOrRef);\n      const info = this._monitoredElements.get(element);\n      if (info) {\n        return info.subject;\n      }\n      const subject = new Subject();\n      const cssClass = 'cdk-text-field-autofilled';\n      const listener = event => {\n        // Animation events fire on initial element render, we check for the presence of the autofill\n        // CSS class to make sure this is a real change in state, not just the initial render before\n        // we fire off events.\n        if (event.animationName === 'cdk-text-field-autofill-start' && !element.classList.contains(cssClass)) {\n          element.classList.add(cssClass);\n          this._ngZone.run(() => subject.next({\n            target: event.target,\n            isAutofilled: true\n          }));\n        } else if (event.animationName === 'cdk-text-field-autofill-end' && element.classList.contains(cssClass)) {\n          element.classList.remove(cssClass);\n          this._ngZone.run(() => subject.next({\n            target: event.target,\n            isAutofilled: false\n          }));\n        }\n      };\n      const unlisten = this._ngZone.runOutsideAngular(() => {\n        element.classList.add('cdk-text-field-autofill-monitored');\n        return this._renderer.listen(element, 'animationstart', listener, listenerOptions);\n      });\n      this._monitoredElements.set(element, {\n        subject,\n        unlisten\n      });\n      return subject;\n    }\n    stopMonitoring(elementOrRef) {\n      const element = coerceElement(elementOrRef);\n      const info = this._monitoredElements.get(element);\n      if (info) {\n        info.unlisten();\n        info.subject.complete();\n        element.classList.remove('cdk-text-field-autofill-monitored');\n        element.classList.remove('cdk-text-field-autofilled');\n        this._monitoredElements.delete(element);\n      }\n    }\n    ngOnDestroy() {\n      this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    static ɵfac = function AutofillMonitor_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AutofillMonitor)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: AutofillMonitor,\n      factory: AutofillMonitor.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return AutofillMonitor;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** A directive that can be used to monitor the autofill state of an input. */\nlet CdkAutofill = /*#__PURE__*/(() => {\n  class CdkAutofill {\n    _elementRef = inject(ElementRef);\n    _autofillMonitor = inject(AutofillMonitor);\n    /** Emits when the autofill state of the element changes. */\n    cdkAutofill = new EventEmitter();\n    constructor() {}\n    ngOnInit() {\n      this._autofillMonitor.monitor(this._elementRef).subscribe(event => this.cdkAutofill.emit(event));\n    }\n    ngOnDestroy() {\n      this._autofillMonitor.stopMonitoring(this._elementRef);\n    }\n    static ɵfac = function CdkAutofill_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkAutofill)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkAutofill,\n      selectors: [[\"\", \"cdkAutofill\", \"\"]],\n      outputs: {\n        cdkAutofill: \"cdkAutofill\"\n      }\n    });\n  }\n  return CdkAutofill;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Directive to automatically resize a textarea to fit its content. */\nlet CdkTextareaAutosize = /*#__PURE__*/(() => {\n  class CdkTextareaAutosize {\n    _elementRef = inject(ElementRef);\n    _platform = inject(Platform);\n    _ngZone = inject(NgZone);\n    _renderer = inject(Renderer2);\n    _resizeEvents = new Subject();\n    /** Keep track of the previous textarea value to avoid resizing when the value hasn't changed. */\n    _previousValue;\n    _initialHeight;\n    _destroyed = new Subject();\n    _listenerCleanups;\n    _minRows;\n    _maxRows;\n    _enabled = true;\n    /**\n     * Value of minRows as of last resize. If the minRows has decreased, the\n     * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n     * does not have the same problem because it does not affect the textarea's scrollHeight.\n     */\n    _previousMinRows = -1;\n    _textareaElement;\n    /** Minimum amount of rows in the textarea. */\n    get minRows() {\n      return this._minRows;\n    }\n    set minRows(value) {\n      this._minRows = coerceNumberProperty(value);\n      this._setMinHeight();\n    }\n    /** Maximum amount of rows in the textarea. */\n    get maxRows() {\n      return this._maxRows;\n    }\n    set maxRows(value) {\n      this._maxRows = coerceNumberProperty(value);\n      this._setMaxHeight();\n    }\n    /** Whether autosizing is enabled or not */\n    get enabled() {\n      return this._enabled;\n    }\n    set enabled(value) {\n      // Only act if the actual value changed. This specifically helps to not run\n      // resizeToFitContent too early (i.e. before ngAfterViewInit)\n      if (this._enabled !== value) {\n        (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n      }\n    }\n    get placeholder() {\n      return this._textareaElement.placeholder;\n    }\n    set placeholder(value) {\n      this._cachedPlaceholderHeight = undefined;\n      if (value) {\n        this._textareaElement.setAttribute('placeholder', value);\n      } else {\n        this._textareaElement.removeAttribute('placeholder');\n      }\n      this._cacheTextareaPlaceholderHeight();\n    }\n    /** Cached height of a textarea with a single row. */\n    _cachedLineHeight;\n    /** Cached height of a textarea with only the placeholder. */\n    _cachedPlaceholderHeight;\n    /** Cached scroll top of a textarea */\n    _cachedScrollTop;\n    /** Used to reference correct document/window */\n    _document = inject(DOCUMENT, {\n      optional: true\n    });\n    _hasFocus;\n    _isViewInited = false;\n    constructor() {\n      const styleLoader = inject(_CdkPrivateStyleLoader);\n      styleLoader.load(_CdkTextFieldStyleLoader);\n      this._textareaElement = this._elementRef.nativeElement;\n    }\n    /** Sets the minimum height of the textarea as determined by minRows. */\n    _setMinHeight() {\n      const minHeight = this.minRows && this._cachedLineHeight ? `${this.minRows * this._cachedLineHeight}px` : null;\n      if (minHeight) {\n        this._textareaElement.style.minHeight = minHeight;\n      }\n    }\n    /** Sets the maximum height of the textarea as determined by maxRows. */\n    _setMaxHeight() {\n      const maxHeight = this.maxRows && this._cachedLineHeight ? `${this.maxRows * this._cachedLineHeight}px` : null;\n      if (maxHeight) {\n        this._textareaElement.style.maxHeight = maxHeight;\n      }\n    }\n    ngAfterViewInit() {\n      if (this._platform.isBrowser) {\n        // Remember the height which we started with in case autosizing is disabled\n        this._initialHeight = this._textareaElement.style.height;\n        this.resizeToFitContent();\n        this._ngZone.runOutsideAngular(() => {\n          this._listenerCleanups = [this._renderer.listen('window', 'resize', () => this._resizeEvents.next()), this._renderer.listen(this._textareaElement, 'focus', this._handleFocusEvent), this._renderer.listen(this._textareaElement, 'blur', this._handleFocusEvent)];\n          this._resizeEvents.pipe(auditTime(16)).subscribe(() => {\n            // Clear the cached heights since the styles can change\n            // when the window is resized (e.g. by media queries).\n            this._cachedLineHeight = this._cachedPlaceholderHeight = undefined;\n            this.resizeToFitContent(true);\n          });\n        });\n        this._isViewInited = true;\n        this.resizeToFitContent(true);\n      }\n    }\n    ngOnDestroy() {\n      this._listenerCleanups?.forEach(cleanup => cleanup());\n      this._resizeEvents.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     */\n    _cacheTextareaLineHeight() {\n      if (this._cachedLineHeight) {\n        return;\n      }\n      // Use a clone element because we have to override some styles.\n      const textareaClone = this._textareaElement.cloneNode(false);\n      const cloneStyles = textareaClone.style;\n      textareaClone.rows = 1;\n      // Use `position: absolute` so that this doesn't cause a browser layout and use\n      // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n      // would affect the height.\n      cloneStyles.position = 'absolute';\n      cloneStyles.visibility = 'hidden';\n      cloneStyles.border = 'none';\n      cloneStyles.padding = '0';\n      cloneStyles.height = '';\n      cloneStyles.minHeight = '';\n      cloneStyles.maxHeight = '';\n      // App styles might be messing with the height through the positioning properties.\n      cloneStyles.top = cloneStyles.bottom = cloneStyles.left = cloneStyles.right = 'auto';\n      // In Firefox it happens that textarea elements are always bigger than the specified amount\n      // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n      // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n      // to hidden. This ensures that there is no invalid calculation of the line height.\n      // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n      cloneStyles.overflow = 'hidden';\n      this._textareaElement.parentNode.appendChild(textareaClone);\n      this._cachedLineHeight = textareaClone.clientHeight;\n      textareaClone.remove();\n      // Min and max heights have to be re-calculated if the cached line height changes\n      this._setMinHeight();\n      this._setMaxHeight();\n    }\n    _measureScrollHeight() {\n      const element = this._textareaElement;\n      const previousMargin = element.style.marginBottom || '';\n      const isFirefox = this._platform.FIREFOX;\n      const needsMarginFiller = isFirefox && this._hasFocus;\n      const measuringClass = isFirefox ? 'cdk-textarea-autosize-measuring-firefox' : 'cdk-textarea-autosize-measuring';\n      // In some cases the page might move around while we're measuring the `textarea` on Firefox. We\n      // work around it by assigning a temporary margin with the same height as the `textarea` so that\n      // it occupies the same amount of space. See #23233.\n      if (needsMarginFiller) {\n        element.style.marginBottom = `${element.clientHeight}px`;\n      }\n      // Reset the textarea height to auto in order to shrink back to its default size.\n      // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n      element.classList.add(measuringClass);\n      // The measuring class includes a 2px padding to workaround an issue with Chrome,\n      // so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n      const scrollHeight = element.scrollHeight - 4;\n      element.classList.remove(measuringClass);\n      if (needsMarginFiller) {\n        element.style.marginBottom = previousMargin;\n      }\n      return scrollHeight;\n    }\n    _cacheTextareaPlaceholderHeight() {\n      if (!this._isViewInited || this._cachedPlaceholderHeight != undefined) {\n        return;\n      }\n      if (!this.placeholder) {\n        this._cachedPlaceholderHeight = 0;\n        return;\n      }\n      const value = this._textareaElement.value;\n      this._textareaElement.value = this._textareaElement.placeholder;\n      this._cachedPlaceholderHeight = this._measureScrollHeight();\n      this._textareaElement.value = value;\n    }\n    /** Handles `focus` and `blur` events. */\n    _handleFocusEvent = event => {\n      this._hasFocus = event.type === 'focus';\n    };\n    ngDoCheck() {\n      if (this._platform.isBrowser) {\n        this.resizeToFitContent();\n      }\n    }\n    /**\n     * Resize the textarea to fit its content.\n     * @param force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     */\n    resizeToFitContent(force = false) {\n      // If autosizing is disabled, just skip everything else\n      if (!this._enabled) {\n        return;\n      }\n      this._cacheTextareaLineHeight();\n      this._cacheTextareaPlaceholderHeight();\n      this._cachedScrollTop = this._textareaElement.scrollTop;\n      // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n      // in checking the height of the textarea.\n      if (!this._cachedLineHeight) {\n        return;\n      }\n      const textarea = this._elementRef.nativeElement;\n      const value = textarea.value;\n      // Only resize if the value or minRows have changed since these calculations can be expensive.\n      if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n        return;\n      }\n      const scrollHeight = this._measureScrollHeight();\n      const height = Math.max(scrollHeight, this._cachedPlaceholderHeight || 0);\n      // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n      textarea.style.height = `${height}px`;\n      this._ngZone.runOutsideAngular(() => {\n        if (typeof requestAnimationFrame !== 'undefined') {\n          requestAnimationFrame(() => this._scrollToCaretPosition(textarea));\n        } else {\n          setTimeout(() => this._scrollToCaretPosition(textarea));\n        }\n      });\n      this._previousValue = value;\n      this._previousMinRows = this._minRows;\n    }\n    /**\n     * Resets the textarea to its original size\n     */\n    reset() {\n      // Do not try to change the textarea, if the initialHeight has not been determined yet\n      // This might potentially remove styles when reset() is called before ngAfterViewInit\n      if (this._initialHeight !== undefined) {\n        this._textareaElement.style.height = this._initialHeight;\n      }\n    }\n    _noopInputHandler() {\n      // no-op handler that ensures we're running change detection on input events.\n    }\n    /**\n     * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n     * prevent it from scrolling to the caret position. We need to re-set the selection\n     * in order for it to scroll to the proper position.\n     */\n    _scrollToCaretPosition(textarea) {\n      const {\n        selectionStart,\n        selectionEnd\n      } = textarea;\n      // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n      // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n      // between the time we requested the animation frame and when it was executed.\n      // Also note that we have to assert that the textarea is focused before we set the\n      // selection range. Setting the selection range on a non-focused textarea will cause\n      // it to receive focus on IE and Edge.\n      if (!this._destroyed.isStopped && this._hasFocus) {\n        textarea.setSelectionRange(selectionStart, selectionEnd);\n        textarea.scrollTop = this._cachedScrollTop;\n      }\n    }\n    static ɵfac = function CdkTextareaAutosize_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTextareaAutosize)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTextareaAutosize,\n      selectors: [[\"textarea\", \"cdkTextareaAutosize\", \"\"]],\n      hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\"],\n      hostBindings: function CdkTextareaAutosize_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"input\", function CdkTextareaAutosize_input_HostBindingHandler() {\n            return ctx._noopInputHandler();\n          });\n        }\n      },\n      inputs: {\n        minRows: [0, \"cdkAutosizeMinRows\", \"minRows\"],\n        maxRows: [0, \"cdkAutosizeMaxRows\", \"maxRows\"],\n        enabled: [2, \"cdkTextareaAutosize\", \"enabled\", booleanAttribute],\n        placeholder: \"placeholder\"\n      },\n      exportAs: [\"cdkTextareaAutosize\"]\n    });\n  }\n  return CdkTextareaAutosize;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TextFieldModule = /*#__PURE__*/(() => {\n  class TextFieldModule {\n    static ɵfac = function TextFieldModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TextFieldModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: TextFieldModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return TextFieldModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule };\n","import { InjectionToken } from '@angular/core';\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nconst MAT_INPUT_VALUE_ACCESSOR = /*#__PURE__*/new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\nexport { MAT_INPUT_VALUE_ACCESSOR as M };\n","import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform, getSupportedInputTypes } from '@angular/cdk/platform';\nimport { AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, NgZone, Renderer2, isSignal, effect, booleanAttribute, Directive, Input, NgModule } from '@angular/core';\nimport { _IdGenerator } from '@angular/cdk/a11y';\nimport { NgControl, Validators, NgForm, FormGroupDirective } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { M as MAT_INPUT_VALUE_ACCESSOR } from './input-value-accessor-D1GvPuqO.mjs';\nimport { h as MAT_FORM_FIELD, k as MatFormFieldControl } from './form-field-C9DZXojn.mjs';\nexport { b as MatError, j as MatFormField, c as MatHint, M as MatLabel, e as MatPrefix, g as MatSuffix } from './form-field-C9DZXojn.mjs';\nimport { E as ErrorStateMatcher } from './error-options-DCNQlTOA.mjs';\nimport { _ as _ErrorStateTracker } from './error-state-Dtb1IHM-.mjs';\nimport { M as MatFormFieldModule } from './module-DzZHEh7B.mjs';\nimport { M as MatCommonModule } from './common-module-cKSwHniA.mjs';\nimport '@angular/cdk/bidi';\nimport '@angular/common';\nimport 'rxjs/operators';\nimport '@angular/cdk/observers/private';\nimport './animation-DfMFjxHu.mjs';\nimport '@angular/cdk/layout';\nimport '@angular/cdk/observers';\n\n/** @docs-private */\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\n/** Injection token that can be used to provide the default options for the input. */\nconst MAT_INPUT_CONFIG = /*#__PURE__*/new InjectionToken('MAT_INPUT_CONFIG');\nlet MatInput = /*#__PURE__*/(() => {\n  class MatInput {\n    _elementRef = inject(ElementRef);\n    _platform = inject(Platform);\n    ngControl = inject(NgControl, {\n      optional: true,\n      self: true\n    });\n    _autofillMonitor = inject(AutofillMonitor);\n    _ngZone = inject(NgZone);\n    _formField = inject(MAT_FORM_FIELD, {\n      optional: true\n    });\n    _renderer = inject(Renderer2);\n    _uid = inject(_IdGenerator).getId('mat-input-');\n    _previousNativeValue;\n    _inputValueAccessor;\n    _signalBasedValueAccessor;\n    _previousPlaceholder;\n    _errorStateTracker;\n    _config = inject(MAT_INPUT_CONFIG, {\n      optional: true\n    });\n    _cleanupIosKeyup;\n    _cleanupWebkitWheel;\n    /** Whether the component is being rendered on the server. */\n    _isServer;\n    /** Whether the component is a native html select. */\n    _isNativeSelect;\n    /** Whether the component is a textarea. */\n    _isTextarea;\n    /** Whether the input is inside of a form field. */\n    _isInFormField;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    focused = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    stateChanges = new Subject();\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    controlType = 'mat-input';\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    autofilled = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n      // Browsers may not fire the blur event if the input is disabled too quickly.\n      // Reset from here to ensure that the element doesn't become stuck.\n      if (this.focused) {\n        this.focused = false;\n        this.stateChanges.next();\n      }\n    }\n    _disabled = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get id() {\n      return this._id;\n    }\n    set id(value) {\n      this._id = value || this._uid;\n    }\n    _id;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    placeholder;\n    /**\n     * Name of the input.\n     * @docs-private\n     */\n    name;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get required() {\n      return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n    }\n    set required(value) {\n      this._required = coerceBooleanProperty(value);\n    }\n    _required;\n    /** Input type of the element. */\n    get type() {\n      return this._type;\n    }\n    set type(value) {\n      const prevType = this._type;\n      this._type = value || 'text';\n      this._validateType();\n      // When using Angular inputs, developers are no longer able to set the properties on the native\n      // input element. To ensure that bindings for `type` work, we need to sync the setter\n      // with the native property. Textarea elements don't support the type property or attribute.\n      if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n        this._elementRef.nativeElement.type = this._type;\n      }\n      if (this._type !== prevType) {\n        this._ensureWheelDefaultBehavior();\n      }\n    }\n    _type = 'text';\n    /** An object used to control when error messages are shown. */\n    get errorStateMatcher() {\n      return this._errorStateTracker.matcher;\n    }\n    set errorStateMatcher(value) {\n      this._errorStateTracker.matcher = value;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    userAriaDescribedBy;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get value() {\n      return this._signalBasedValueAccessor ? this._signalBasedValueAccessor.value() : this._inputValueAccessor.value;\n    }\n    set value(value) {\n      if (value !== this.value) {\n        if (this._signalBasedValueAccessor) {\n          this._signalBasedValueAccessor.value.set(value);\n        } else {\n          this._inputValueAccessor.value = value;\n        }\n        this.stateChanges.next();\n      }\n    }\n    /** Whether the element is readonly. */\n    get readonly() {\n      return this._readonly;\n    }\n    set readonly(value) {\n      this._readonly = coerceBooleanProperty(value);\n    }\n    _readonly = false;\n    /** Whether the input should remain interactive when it is disabled. */\n    disabledInteractive;\n    /** Whether the input is in an error state. */\n    get errorState() {\n      return this._errorStateTracker.errorState;\n    }\n    set errorState(value) {\n      this._errorStateTracker.errorState = value;\n    }\n    _neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(t => getSupportedInputTypes().has(t));\n    constructor() {\n      const parentForm = inject(NgForm, {\n        optional: true\n      });\n      const parentFormGroup = inject(FormGroupDirective, {\n        optional: true\n      });\n      const defaultErrorStateMatcher = inject(ErrorStateMatcher);\n      const accessor = inject(MAT_INPUT_VALUE_ACCESSOR, {\n        optional: true,\n        self: true\n      });\n      const element = this._elementRef.nativeElement;\n      const nodeName = element.nodeName.toLowerCase();\n      if (accessor) {\n        if (isSignal(accessor.value)) {\n          this._signalBasedValueAccessor = accessor;\n        } else {\n          this._inputValueAccessor = accessor;\n        }\n      } else {\n        // If no input value accessor was explicitly specified, use the element as the input value\n        // accessor.\n        this._inputValueAccessor = element;\n      }\n      this._previousNativeValue = this.value;\n      // Force setter to be called in case id was not specified.\n      this.id = this.id;\n      // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n      // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n      // exists on iOS, we only bother to install the listener on iOS.\n      if (this._platform.IOS) {\n        this._ngZone.runOutsideAngular(() => {\n          this._cleanupIosKeyup = this._renderer.listen(element, 'keyup', this._iOSKeyupListener);\n        });\n      }\n      this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, this.ngControl, parentFormGroup, parentForm, this.stateChanges);\n      this._isServer = !this._platform.isBrowser;\n      this._isNativeSelect = nodeName === 'select';\n      this._isTextarea = nodeName === 'textarea';\n      this._isInFormField = !!this._formField;\n      this.disabledInteractive = this._config?.disabledInteractive || false;\n      if (this._isNativeSelect) {\n        this.controlType = element.multiple ? 'mat-native-select-multiple' : 'mat-native-select';\n      }\n      if (this._signalBasedValueAccessor) {\n        effect(() => {\n          // Read the value so the effect can register the dependency.\n          this._signalBasedValueAccessor.value();\n          this.stateChanges.next();\n        });\n      }\n    }\n    ngAfterViewInit() {\n      if (this._platform.isBrowser) {\n        this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n          this.autofilled = event.isAutofilled;\n          this.stateChanges.next();\n        });\n      }\n    }\n    ngOnChanges() {\n      this.stateChanges.next();\n    }\n    ngOnDestroy() {\n      this.stateChanges.complete();\n      if (this._platform.isBrowser) {\n        this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n      }\n      this._cleanupIosKeyup?.();\n      this._cleanupWebkitWheel?.();\n    }\n    ngDoCheck() {\n      if (this.ngControl) {\n        // We need to re-evaluate this on every change detection cycle, because there are some\n        // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n        // that whatever logic is in here has to be super lean or we risk destroying the performance.\n        this.updateErrorState();\n        // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n        // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n        // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n        // disabled.\n        if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n          this.disabled = this.ngControl.disabled;\n          this.stateChanges.next();\n        }\n      }\n      // We need to dirty-check the native element's value, because there are some cases where\n      // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n      // updating the value using `emitEvent: false`).\n      this._dirtyCheckNativeValue();\n      // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n      // present or not depends on a query which is prone to \"changed after checked\" errors.\n      this._dirtyCheckPlaceholder();\n    }\n    /** Focuses the input. */\n    focus(options) {\n      this._elementRef.nativeElement.focus(options);\n    }\n    /** Refreshes the error state of the input. */\n    updateErrorState() {\n      this._errorStateTracker.updateErrorState();\n    }\n    /** Callback for the cases where the focused state of the input changes. */\n    _focusChanged(isFocused) {\n      if (isFocused === this.focused) {\n        return;\n      }\n      if (!this._isNativeSelect && isFocused && this.disabled && this.disabledInteractive) {\n        const element = this._elementRef.nativeElement;\n        // Focusing an input that has text will cause all the text to be selected. Clear it since\n        // the user won't be able to change it. This is based on the internal implementation.\n        if (element.type === 'number') {\n          // setSelectionRange doesn't work on number inputs so it needs to be set briefly to text.\n          element.type = 'text';\n          element.setSelectionRange(0, 0);\n          element.type = 'number';\n        } else {\n          element.setSelectionRange(0, 0);\n        }\n      }\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n    _onInput() {\n      // This is a noop function and is used to let Angular know whenever the value changes.\n      // Angular will run a new change detection each time the `input` event has been dispatched.\n      // It's necessary that Angular recognizes the value change, because when floatingLabel\n      // is set to false and Angular forms aren't used, the placeholder won't recognize the\n      // value changes and will not disappear.\n      // Listening to the input event wouldn't be necessary when the input is using the\n      // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /** Does some manual dirty checking on the native input `value` property. */\n    _dirtyCheckNativeValue() {\n      const newValue = this._elementRef.nativeElement.value;\n      if (this._previousNativeValue !== newValue) {\n        this._previousNativeValue = newValue;\n        this.stateChanges.next();\n      }\n    }\n    /** Does some manual dirty checking on the native input `placeholder` attribute. */\n    _dirtyCheckPlaceholder() {\n      const placeholder = this._getPlaceholder();\n      if (placeholder !== this._previousPlaceholder) {\n        const element = this._elementRef.nativeElement;\n        this._previousPlaceholder = placeholder;\n        placeholder ? element.setAttribute('placeholder', placeholder) : element.removeAttribute('placeholder');\n      }\n    }\n    /** Gets the current placeholder of the form field. */\n    _getPlaceholder() {\n      return this.placeholder || null;\n    }\n    /** Make sure the input is a supported type. */\n    _validateType() {\n      if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatInputUnsupportedTypeError(this._type);\n      }\n    }\n    /** Checks whether the input type is one of the types that are never empty. */\n    _isNeverEmpty() {\n      return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /** Checks whether the input is invalid based on the native validation. */\n    _isBadInput() {\n      // The `validity` property won't be present on platform-server.\n      let validity = this._elementRef.nativeElement.validity;\n      return validity && validity.badInput;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get empty() {\n      return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat() {\n      if (this._isNativeSelect) {\n        // For a single-selection `<select>`, the label should float when the selected option has\n        // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n        // overlapping the label with the options.\n        const selectElement = this._elementRef.nativeElement;\n        const firstOption = selectElement.options[0];\n        // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n        // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n        return this.focused || selectElement.multiple || !this.empty || !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n      } else {\n        return this.focused && !this.disabled || !this.empty;\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get describedByIds() {\n      const element = this._elementRef.nativeElement;\n      const existingDescribedBy = element.getAttribute('aria-describedby');\n      return existingDescribedBy?.split(' ') || [];\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids) {\n      const element = this._elementRef.nativeElement;\n      if (ids.length) {\n        element.setAttribute('aria-describedby', ids.join(' '));\n      } else {\n        element.removeAttribute('aria-describedby');\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick() {\n      // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n      // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n      // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n      if (!this.focused) {\n        this.focus();\n      }\n    }\n    /** Whether the form control is a native select that is displayed inline. */\n    _isInlineSelect() {\n      const element = this._elementRef.nativeElement;\n      return this._isNativeSelect && (element.multiple || element.size > 1);\n    }\n    _iOSKeyupListener = event => {\n      const el = event.target;\n      // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n      // indicate different things. If the value is 0, it means that the caret is at the start\n      // of the input, whereas a value of `null` means that the input doesn't support\n      // manipulating the selection range. Inputs that don't support setting the selection range\n      // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n      // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n      if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n        // Note: Just setting `0, 0` doesn't fix the issue. Setting\n        // `1, 1` fixes it for the first time that you type text and\n        // then hold delete. Toggling to `1, 1` and then back to\n        // `0, 0` seems to completely fix it.\n        el.setSelectionRange(1, 1);\n        el.setSelectionRange(0, 0);\n      }\n    };\n    _webkitBlinkWheelListener = () => {\n      // This is a noop function and is used to enable mouse wheel input\n      // on number inputs\n      // on blink and webkit browsers.\n    };\n    /**\n     * In blink and webkit browsers a focused number input does not increment or decrement its value\n     * on mouse wheel interaction unless a wheel event listener is attached to it or one of its\n     * ancestors or a passive wheel listener is attached somewhere in the DOM. For example: Hitting\n     * a tooltip once enables the mouse wheel input for all number inputs as long as it exists. In\n     * order to get reliable and intuitive behavior we apply a wheel event on our own thus making\n     * sure increment and decrement by mouse wheel works every time.\n     * @docs-private\n     */\n    _ensureWheelDefaultBehavior() {\n      this._cleanupWebkitWheel?.();\n      if (this._type === 'number' && (this._platform.BLINK || this._platform.WEBKIT)) {\n        this._cleanupWebkitWheel = this._renderer.listen(this._elementRef.nativeElement, 'wheel', this._webkitBlinkWheelListener);\n      }\n    }\n    /** Gets the value to set on the `readonly` attribute. */\n    _getReadonlyAttribute() {\n      if (this._isNativeSelect) {\n        return null;\n      }\n      if (this.readonly || this.disabled && this.disabledInteractive) {\n        return 'true';\n      }\n      return null;\n    }\n    static ɵfac = function MatInput_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatInput)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatInput,\n      selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]],\n      hostAttrs: [1, \"mat-mdc-input-element\"],\n      hostVars: 21,\n      hostBindings: function MatInput_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"focus\", function MatInput_focus_HostBindingHandler() {\n            return ctx._focusChanged(true);\n          })(\"blur\", function MatInput_blur_HostBindingHandler() {\n            return ctx._focusChanged(false);\n          })(\"input\", function MatInput_input_HostBindingHandler() {\n            return ctx._onInput();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"id\", ctx.id)(\"disabled\", ctx.disabled && !ctx.disabledInteractive)(\"required\", ctx.required);\n          i0.ɵɵattribute(\"name\", ctx.name || null)(\"readonly\", ctx._getReadonlyAttribute())(\"aria-disabled\", ctx.disabled && ctx.disabledInteractive ? \"true\" : null)(\"aria-invalid\", ctx.empty && ctx.required ? null : ctx.errorState)(\"aria-required\", ctx.required)(\"id\", ctx.id);\n          i0.ɵɵclassProp(\"mat-input-server\", ctx._isServer)(\"mat-mdc-form-field-textarea-control\", ctx._isInFormField && ctx._isTextarea)(\"mat-mdc-form-field-input-control\", ctx._isInFormField)(\"mat-mdc-input-disabled-interactive\", ctx.disabledInteractive)(\"mdc-text-field__input\", ctx._isInFormField)(\"mat-mdc-native-select-inline\", ctx._isInlineSelect());\n        }\n      },\n      inputs: {\n        disabled: \"disabled\",\n        id: \"id\",\n        placeholder: \"placeholder\",\n        name: \"name\",\n        required: \"required\",\n        type: \"type\",\n        errorStateMatcher: \"errorStateMatcher\",\n        userAriaDescribedBy: [0, \"aria-describedby\", \"userAriaDescribedBy\"],\n        value: \"value\",\n        readonly: \"readonly\",\n        disabledInteractive: [2, \"disabledInteractive\", \"disabledInteractive\", booleanAttribute]\n      },\n      exportAs: [\"matInput\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MatFormFieldControl,\n        useExisting: MatInput\n      }]), i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return MatInput;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatInputModule = /*#__PURE__*/(() => {\n  class MatInputModule {\n    static ɵfac = function MatInputModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatInputModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatInputModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [MatCommonModule, MatFormFieldModule, MatFormFieldModule, TextFieldModule, MatCommonModule]\n    });\n  }\n  return MatInputModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { MAT_INPUT_CONFIG, MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, getMatInputUnsupportedTypeError };\n","import { FocusTrapFactory, FocusMonitor, InteractivityChecker } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nimport { Platform } from '@angular/cdk/platform';\nimport { CdkScrollable, ScrollDispatcher, ViewportRuler, CdkScrollableModule } from '@angular/cdk/scrolling';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ChangeDetectorRef, ElementRef, NgZone, Component, ChangeDetectionStrategy, ViewEncapsulation, Renderer2, DOCUMENT, signal, EventEmitter, Injector, afterNextRender, Input, Output, ViewChild, QueryList, ContentChildren, ContentChild, NgModule } from '@angular/core';\nimport { Subject, fromEvent, merge } from 'rxjs';\nimport { filter, map, mapTo, takeUntil, take, startWith, debounceTime } from 'rxjs/operators';\nimport { _ as _animationsDisabled } from './animation-DfMFjxHu.mjs';\nimport { M as MatCommonModule } from './common-module-cKSwHniA.mjs';\nimport '@angular/cdk/layout';\n\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @docs-private\n */\nconst _c0 = [\"*\"];\nconst _c1 = [\"content\"];\nconst _c2 = [[[\"mat-drawer\"]], [[\"mat-drawer-content\"]], \"*\"];\nconst _c3 = [\"mat-drawer\", \"mat-drawer-content\", \"*\"];\nfunction MatDrawerContainer_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵlistener(\"click\", function MatDrawerContainer_Conditional_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._onBackdropClicked());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"mat-drawer-shown\", ctx_r1._isShowingBackdrop());\n  }\n}\nfunction MatDrawerContainer_Conditional_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-drawer-content\");\n    i0.ɵɵprojection(1, 2);\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c4 = [[[\"mat-sidenav\"]], [[\"mat-sidenav-content\"]], \"*\"];\nconst _c5 = [\"mat-sidenav\", \"mat-sidenav-content\", \"*\"];\nfunction MatSidenavContainer_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵlistener(\"click\", function MatSidenavContainer_Conditional_0_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._onBackdropClicked());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"mat-drawer-shown\", ctx_r1._isShowingBackdrop());\n  }\n}\nfunction MatSidenavContainer_Conditional_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-sidenav-content\");\n    i0.ɵɵprojection(1, 2);\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c6 = \".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\\n\";\nfunction throwMatDuplicatedDrawerError(position) {\n  throw Error(`A drawer was already declared for 'position=\"${position}\"'`);\n}\n/** Configures whether drawers should use auto sizing by default. */\nconst MAT_DRAWER_DEFAULT_AUTOSIZE = /*#__PURE__*/new InjectionToken('MAT_DRAWER_DEFAULT_AUTOSIZE', {\n  providedIn: 'root',\n  factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY\n});\n/**\n * Used to provide a drawer container to a drawer while avoiding circular references.\n * @docs-private\n */\nconst MAT_DRAWER_CONTAINER = /*#__PURE__*/new InjectionToken('MAT_DRAWER_CONTAINER');\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {\n  return false;\n}\nlet MatDrawerContent = /*#__PURE__*/(() => {\n  class MatDrawerContent extends CdkScrollable {\n    _platform = inject(Platform);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _container = inject(MatDrawerContainer);\n    constructor() {\n      const elementRef = inject(ElementRef);\n      const scrollDispatcher = inject(ScrollDispatcher);\n      const ngZone = inject(NgZone);\n      super(elementRef, scrollDispatcher, ngZone);\n    }\n    ngAfterContentInit() {\n      this._container._contentMarginChanges.subscribe(() => {\n        this._changeDetectorRef.markForCheck();\n      });\n    }\n    /** Determines whether the content element should be hidden from the user. */\n    _shouldBeHidden() {\n      // In some modes the content is pushed based on the width of the opened sidenavs, however on\n      // the server we can't measure the sidenav so the margin is always zero. This can cause the\n      // content to jump around when it's rendered on the server and hydrated on the client. We\n      // avoid it by hiding the content on the initial render and then showing it once the sidenav\n      // has been measured on the client.\n      if (this._platform.isBrowser) {\n        return false;\n      }\n      const {\n        start,\n        end\n      } = this._container;\n      return start != null && start.mode !== 'over' && start.opened || end != null && end.mode !== 'over' && end.opened;\n    }\n    static ɵfac = function MatDrawerContent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDrawerContent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatDrawerContent,\n      selectors: [[\"mat-drawer-content\"]],\n      hostAttrs: [1, \"mat-drawer-content\"],\n      hostVars: 6,\n      hostBindings: function MatDrawerContent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"margin-left\", ctx._container._contentMargins.left, \"px\")(\"margin-right\", ctx._container._contentMargins.right, \"px\");\n          i0.ɵɵclassProp(\"mat-drawer-content-hidden\", ctx._shouldBeHidden());\n        }\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkScrollable,\n        useExisting: MatDrawerContent\n      }]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c0,\n      decls: 1,\n      vars: 0,\n      template: function MatDrawerContent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatDrawerContent;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * This component corresponds to a drawer that can be opened on the drawer container.\n */\nlet MatDrawer = /*#__PURE__*/(() => {\n  class MatDrawer {\n    _elementRef = inject(ElementRef);\n    _focusTrapFactory = inject(FocusTrapFactory);\n    _focusMonitor = inject(FocusMonitor);\n    _platform = inject(Platform);\n    _ngZone = inject(NgZone);\n    _renderer = inject(Renderer2);\n    _interactivityChecker = inject(InteractivityChecker);\n    _doc = inject(DOCUMENT, {\n      optional: true\n    });\n    _container = inject(MAT_DRAWER_CONTAINER, {\n      optional: true\n    });\n    _focusTrap = null;\n    _elementFocusedBeforeDrawerWasOpened = null;\n    _eventCleanups;\n    /** Whether the view of the component has been attached. */\n    _isAttached;\n    /** Anchor node used to restore the drawer to its initial position. */\n    _anchor;\n    /** The side that the drawer is attached to. */\n    get position() {\n      return this._position;\n    }\n    set position(value) {\n      // Make sure we have a valid value.\n      value = value === 'end' ? 'end' : 'start';\n      if (value !== this._position) {\n        // Static inputs in Ivy are set before the element is in the DOM.\n        if (this._isAttached) {\n          this._updatePositionInParent(value);\n        }\n        this._position = value;\n        this.onPositionChanged.emit();\n      }\n    }\n    _position = 'start';\n    /** Mode of the drawer; one of 'over', 'push' or 'side'. */\n    get mode() {\n      return this._mode;\n    }\n    set mode(value) {\n      this._mode = value;\n      this._updateFocusTrapState();\n      this._modeChanged.next();\n    }\n    _mode = 'over';\n    /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\n    get disableClose() {\n      return this._disableClose;\n    }\n    set disableClose(value) {\n      this._disableClose = coerceBooleanProperty(value);\n    }\n    _disableClose = false;\n    /**\n     * Whether the drawer should focus the first focusable element automatically when opened.\n     * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly\n     * enabled, focus will be moved into the sidenav in `side` mode as well.\n     * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or AutoFocusTarget\n     * instead.\n     */\n    get autoFocus() {\n      const value = this._autoFocus;\n      // Note that usually we don't allow autoFocus to be set to `first-tabbable` in `side` mode,\n      // because we don't know how the sidenav is being used, but in some cases it still makes\n      // sense to do it. The consumer can explicitly set `autoFocus`.\n      if (value == null) {\n        if (this.mode === 'side') {\n          return 'dialog';\n        } else {\n          return 'first-tabbable';\n        }\n      }\n      return value;\n    }\n    set autoFocus(value) {\n      if (value === 'true' || value === 'false' || value == null) {\n        value = coerceBooleanProperty(value);\n      }\n      this._autoFocus = value;\n    }\n    _autoFocus;\n    /**\n     * Whether the drawer is opened. We overload this because we trigger an event when it\n     * starts or end.\n     */\n    get opened() {\n      return this._opened();\n    }\n    set opened(value) {\n      this.toggle(coerceBooleanProperty(value));\n    }\n    _opened = signal(false);\n    /** How the sidenav was opened (keypress, mouse click etc.) */\n    _openedVia;\n    /** Emits whenever the drawer has started animating. */\n    _animationStarted = new Subject();\n    /** Emits whenever the drawer is done animating. */\n    _animationEnd = new Subject();\n    /** Event emitted when the drawer open state is changed. */\n    openedChange =\n    // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\n    new EventEmitter(/* isAsync */true);\n    /** Event emitted when the drawer has been opened. */\n    _openedStream = this.openedChange.pipe(filter(o => o), map(() => {}));\n    /** Event emitted when the drawer has started opening. */\n    openedStart = this._animationStarted.pipe(filter(() => this.opened), mapTo(undefined));\n    /** Event emitted when the drawer has been closed. */\n    _closedStream = this.openedChange.pipe(filter(o => !o), map(() => {}));\n    /** Event emitted when the drawer has started closing. */\n    closedStart = this._animationStarted.pipe(filter(() => !this.opened), mapTo(undefined));\n    /** Emits when the component is destroyed. */\n    _destroyed = new Subject();\n    /** Event emitted when the drawer's position changes. */\n    // tslint:disable-next-line:no-output-on-prefix\n    onPositionChanged = new EventEmitter();\n    /** Reference to the inner element that contains all the content. */\n    _content;\n    /**\n     * An observable that emits when the drawer mode changes. This is used by the drawer container to\n     * to know when to when the mode changes so it can adapt the margins on the content.\n     */\n    _modeChanged = new Subject();\n    _injector = inject(Injector);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    constructor() {\n      this.openedChange.pipe(takeUntil(this._destroyed)).subscribe(opened => {\n        if (opened) {\n          if (this._doc) {\n            this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement;\n          }\n          this._takeFocus();\n        } else if (this._isFocusWithinDrawer()) {\n          this._restoreFocus(this._openedVia || 'program');\n        }\n      });\n      /**\n       * Listen to `keydown` events outside the zone so that change detection is not run every\n       * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\n       * and we don't have close disabled.\n       */\n      this._ngZone.runOutsideAngular(() => {\n        const element = this._elementRef.nativeElement;\n        fromEvent(element, 'keydown').pipe(filter(event => {\n          return event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event);\n        }), takeUntil(this._destroyed)).subscribe(event => this._ngZone.run(() => {\n          this.close();\n          event.stopPropagation();\n          event.preventDefault();\n        }));\n        this._eventCleanups = [this._renderer.listen(element, 'transitionrun', this._handleTransitionEvent), this._renderer.listen(element, 'transitionend', this._handleTransitionEvent), this._renderer.listen(element, 'transitioncancel', this._handleTransitionEvent)];\n      });\n      this._animationEnd.subscribe(() => {\n        this.openedChange.emit(this.opened);\n      });\n    }\n    /**\n     * Focuses the provided element. If the element is not focusable, it will add a tabIndex\n     * attribute to forcefully focus it. The attribute is removed after focus is moved.\n     * @param element The element to focus.\n     */\n    _forceFocus(element, options) {\n      if (!this._interactivityChecker.isFocusable(element)) {\n        element.tabIndex = -1;\n        // The tabindex attribute should be removed to avoid navigating to that element again\n        this._ngZone.runOutsideAngular(() => {\n          const callback = () => {\n            cleanupBlur();\n            cleanupMousedown();\n            element.removeAttribute('tabindex');\n          };\n          const cleanupBlur = this._renderer.listen(element, 'blur', callback);\n          const cleanupMousedown = this._renderer.listen(element, 'mousedown', callback);\n        });\n      }\n      element.focus(options);\n    }\n    /**\n     * Focuses the first element that matches the given selector within the focus trap.\n     * @param selector The CSS selector for the element to set focus to.\n     */\n    _focusByCssSelector(selector, options) {\n      let elementToFocus = this._elementRef.nativeElement.querySelector(selector);\n      if (elementToFocus) {\n        this._forceFocus(elementToFocus, options);\n      }\n    }\n    /**\n     * Moves focus into the drawer. Note that this works even if\n     * the focus trap is disabled in `side` mode.\n     */\n    _takeFocus() {\n      if (!this._focusTrap) {\n        return;\n      }\n      const element = this._elementRef.nativeElement;\n      // When autoFocus is not on the sidenav, if the element cannot be focused or does\n      // not exist, focus the sidenav itself so the keyboard navigation still works.\n      // We need to check that `focus` is a function due to Universal.\n      switch (this.autoFocus) {\n        case false:\n        case 'dialog':\n          return;\n        case true:\n        case 'first-tabbable':\n          afterNextRender(() => {\n            const hasMovedFocus = this._focusTrap.focusInitialElement();\n            if (!hasMovedFocus && typeof element.focus === 'function') {\n              element.focus();\n            }\n          }, {\n            injector: this._injector\n          });\n          break;\n        case 'first-heading':\n          this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role=\"heading\"]');\n          break;\n        default:\n          this._focusByCssSelector(this.autoFocus);\n          break;\n      }\n    }\n    /**\n     * Restores focus to the element that was originally focused when the drawer opened.\n     * If no element was focused at that time, the focus will be restored to the drawer.\n     */\n    _restoreFocus(focusOrigin) {\n      if (this.autoFocus === 'dialog') {\n        return;\n      }\n      if (this._elementFocusedBeforeDrawerWasOpened) {\n        this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, focusOrigin);\n      } else {\n        this._elementRef.nativeElement.blur();\n      }\n      this._elementFocusedBeforeDrawerWasOpened = null;\n    }\n    /** Whether focus is currently within the drawer. */\n    _isFocusWithinDrawer() {\n      const activeEl = this._doc.activeElement;\n      return !!activeEl && this._elementRef.nativeElement.contains(activeEl);\n    }\n    ngAfterViewInit() {\n      this._isAttached = true;\n      // Only update the DOM position when the sidenav is positioned at\n      // the end since we project the sidenav before the content by default.\n      if (this._position === 'end') {\n        this._updatePositionInParent('end');\n      }\n      // Needs to happen after the position is updated\n      // so the focus trap anchors are in the right place.\n      if (this._platform.isBrowser) {\n        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n        this._updateFocusTrapState();\n      }\n    }\n    ngOnDestroy() {\n      this._eventCleanups.forEach(cleanup => cleanup());\n      this._focusTrap?.destroy();\n      this._anchor?.remove();\n      this._anchor = null;\n      this._animationStarted.complete();\n      this._animationEnd.complete();\n      this._modeChanged.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    /**\n     * Open the drawer.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    open(openedVia) {\n      return this.toggle(true, openedVia);\n    }\n    /** Close the drawer. */\n    close() {\n      return this.toggle(false);\n    }\n    /** Closes the drawer with context that the backdrop was clicked. */\n    _closeViaBackdropClick() {\n      // If the drawer is closed upon a backdrop click, we always want to restore focus. We\n      // don't need to check whether focus is currently in the drawer, as clicking on the\n      // backdrop causes blurs the active element.\n      return this._setOpen(/* isOpen */false, /* restoreFocus */true, 'mouse');\n    }\n    /**\n     * Toggle this drawer.\n     * @param isOpen Whether the drawer should be open.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    toggle(isOpen = !this.opened, openedVia) {\n      // If the focus is currently inside the drawer content and we are closing the drawer,\n      // restore the focus to the initially focused element (when the drawer opened).\n      if (isOpen && openedVia) {\n        this._openedVia = openedVia;\n      }\n      const result = this._setOpen(isOpen, /* restoreFocus */!isOpen && this._isFocusWithinDrawer(), this._openedVia || 'program');\n      if (!isOpen) {\n        this._openedVia = null;\n      }\n      return result;\n    }\n    /**\n     * Toggles the opened state of the drawer.\n     * @param isOpen Whether the drawer should open or close.\n     * @param restoreFocus Whether focus should be restored on close.\n     * @param focusOrigin Origin to use when restoring focus.\n     */\n    _setOpen(isOpen, restoreFocus, focusOrigin) {\n      if (isOpen === this.opened) {\n        return Promise.resolve(isOpen ? 'open' : 'close');\n      }\n      this._opened.set(isOpen);\n      if (this._container?._transitionsEnabled) {\n        // Note: it's importatnt to set this as early as possible,\n        // otherwise the animation can look glitchy in some cases.\n        this._setIsAnimating(true);\n      } else {\n        // Simulate the animation events if animations are disabled.\n        setTimeout(() => {\n          this._animationStarted.next();\n          this._animationEnd.next();\n        });\n      }\n      this._elementRef.nativeElement.classList.toggle('mat-drawer-opened', isOpen);\n      if (!isOpen && restoreFocus) {\n        this._restoreFocus(focusOrigin);\n      }\n      // Needed to ensure that the closing sequence fires off correctly.\n      this._changeDetectorRef.markForCheck();\n      this._updateFocusTrapState();\n      return new Promise(resolve => {\n        this.openedChange.pipe(take(1)).subscribe(open => resolve(open ? 'open' : 'close'));\n      });\n    }\n    /** Toggles whether the drawer is currently animating. */\n    _setIsAnimating(isAnimating) {\n      this._elementRef.nativeElement.classList.toggle('mat-drawer-animating', isAnimating);\n    }\n    _getWidth() {\n      return this._elementRef.nativeElement.offsetWidth || 0;\n    }\n    /** Updates the enabled state of the focus trap. */\n    _updateFocusTrapState() {\n      if (this._focusTrap) {\n        // Trap focus only if the backdrop is enabled. Otherwise, allow end user to interact with the\n        // sidenav content.\n        this._focusTrap.enabled = !!this._container?.hasBackdrop && this.opened;\n      }\n    }\n    /**\n     * Updates the position of the drawer in the DOM. We need to move the element around ourselves\n     * when it's in the `end` position so that it comes after the content and the visual order\n     * matches the tab order. We also need to be able to move it back to `start` if the sidenav\n     * started off as `end` and was changed to `start`.\n     */\n    _updatePositionInParent(newPosition) {\n      // Don't move the DOM node around on the server, because it can throw off hydration.\n      if (!this._platform.isBrowser) {\n        return;\n      }\n      const element = this._elementRef.nativeElement;\n      const parent = element.parentNode;\n      if (newPosition === 'end') {\n        if (!this._anchor) {\n          this._anchor = this._doc.createComment('mat-drawer-anchor');\n          parent.insertBefore(this._anchor, element);\n        }\n        parent.appendChild(element);\n      } else if (this._anchor) {\n        this._anchor.parentNode.insertBefore(element, this._anchor);\n      }\n    }\n    /** Event handler for animation events. */\n    _handleTransitionEvent = event => {\n      const element = this._elementRef.nativeElement;\n      if (event.target === element) {\n        this._ngZone.run(() => {\n          if (event.type === 'transitionrun') {\n            this._animationStarted.next(event);\n          } else {\n            // Don't toggle the animating state on `transitioncancel` since another animation should\n            // start afterwards. This prevents the drawer from blinking if an animation is interrupted.\n            if (event.type === 'transitionend') {\n              this._setIsAnimating(false);\n            }\n            this._animationEnd.next(event);\n          }\n        });\n      }\n    };\n    static ɵfac = function MatDrawer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDrawer)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatDrawer,\n      selectors: [[\"mat-drawer\"]],\n      viewQuery: function MatDrawer_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c1, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._content = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mat-drawer\"],\n      hostVars: 12,\n      hostBindings: function MatDrawer_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"align\", null)(\"tabIndex\", ctx.mode !== \"side\" ? \"-1\" : null);\n          i0.ɵɵstyleProp(\"visibility\", !ctx._container && !ctx.opened ? \"hidden\" : null);\n          i0.ɵɵclassProp(\"mat-drawer-end\", ctx.position === \"end\")(\"mat-drawer-over\", ctx.mode === \"over\")(\"mat-drawer-push\", ctx.mode === \"push\")(\"mat-drawer-side\", ctx.mode === \"side\");\n        }\n      },\n      inputs: {\n        position: \"position\",\n        mode: \"mode\",\n        disableClose: \"disableClose\",\n        autoFocus: \"autoFocus\",\n        opened: \"opened\"\n      },\n      outputs: {\n        openedChange: \"openedChange\",\n        _openedStream: \"opened\",\n        openedStart: \"openedStart\",\n        _closedStream: \"closed\",\n        closedStart: \"closedStart\",\n        onPositionChanged: \"positionChanged\"\n      },\n      exportAs: [\"matDrawer\"],\n      ngContentSelectors: _c0,\n      decls: 3,\n      vars: 0,\n      consts: [[\"content\", \"\"], [\"cdkScrollable\", \"\", 1, \"mat-drawer-inner-container\"]],\n      template: function MatDrawer_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", 1, 0);\n          i0.ɵɵprojection(2);\n          i0.ɵɵelementEnd();\n        }\n      },\n      dependencies: [CdkScrollable],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatDrawer;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * `<mat-drawer-container>` component.\n *\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\n * and coordinates the backdrop and content styling.\n */\nlet MatDrawerContainer = /*#__PURE__*/(() => {\n  class MatDrawerContainer {\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _element = inject(ElementRef);\n    _ngZone = inject(NgZone);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _animationDisabled = _animationsDisabled();\n    _transitionsEnabled = false;\n    /** All drawers in the container. Includes drawers from inside nested containers. */\n    _allDrawers;\n    /** Drawers that belong to this container. */\n    _drawers = new QueryList();\n    _content;\n    _userContent;\n    /** The drawer child with the `start` position. */\n    get start() {\n      return this._start;\n    }\n    /** The drawer child with the `end` position. */\n    get end() {\n      return this._end;\n    }\n    /**\n     * Whether to automatically resize the container whenever\n     * the size of any of its drawers changes.\n     *\n     * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\n     * the drawers on every change detection cycle. Can be configured globally via the\n     * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\n     */\n    get autosize() {\n      return this._autosize;\n    }\n    set autosize(value) {\n      this._autosize = coerceBooleanProperty(value);\n    }\n    _autosize = inject(MAT_DRAWER_DEFAULT_AUTOSIZE);\n    /**\n     * Whether the drawer container should have a backdrop while one of the sidenavs is open.\n     * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\n     * mode as well.\n     */\n    get hasBackdrop() {\n      return this._drawerHasBackdrop(this._start) || this._drawerHasBackdrop(this._end);\n    }\n    set hasBackdrop(value) {\n      this._backdropOverride = value == null ? null : coerceBooleanProperty(value);\n    }\n    _backdropOverride;\n    /** Event emitted when the drawer backdrop is clicked. */\n    backdropClick = new EventEmitter();\n    /** The drawer at the start/end position, independent of direction. */\n    _start;\n    _end;\n    /**\n     * The drawer at the left/right. When direction changes, these will change as well.\n     * They're used as aliases for the above to set the left/right style properly.\n     * In LTR, _left == _start and _right == _end.\n     * In RTL, _left == _end and _right == _start.\n     */\n    _left;\n    _right;\n    /** Emits when the component is destroyed. */\n    _destroyed = new Subject();\n    /** Emits on every ngDoCheck. Used for debouncing reflows. */\n    _doCheckSubject = new Subject();\n    /**\n     * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n     * drawer is open. We use margin rather than transform even for push mode because transform breaks\n     * fixed position elements inside of the transformed element.\n     */\n    _contentMargins = {\n      left: null,\n      right: null\n    };\n    _contentMarginChanges = new Subject();\n    /** Reference to the CdkScrollable instance that wraps the scrollable content. */\n    get scrollable() {\n      return this._userContent || this._content;\n    }\n    _injector = inject(Injector);\n    constructor() {\n      const platform = inject(Platform);\n      const viewportRuler = inject(ViewportRuler);\n      // If a `Dir` directive exists up the tree, listen direction changes\n      // and update the left/right properties to point to the proper start/end.\n      this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => {\n        this._validateDrawers();\n        this.updateContentMargins();\n      });\n      // Since the minimum width of the sidenav depends on the viewport width,\n      // we need to recompute the margins if the viewport changes.\n      viewportRuler.change().pipe(takeUntil(this._destroyed)).subscribe(() => this.updateContentMargins());\n      if (!this._animationDisabled && platform.isBrowser) {\n        this._ngZone.runOutsideAngular(() => {\n          // Enable the animations after a delay in order to skip\n          // the initial transition if a drawer is open by default.\n          setTimeout(() => {\n            this._element.nativeElement.classList.add('mat-drawer-transition');\n            this._transitionsEnabled = true;\n          }, 200);\n        });\n      }\n    }\n    ngAfterContentInit() {\n      this._allDrawers.changes.pipe(startWith(this._allDrawers), takeUntil(this._destroyed)).subscribe(drawer => {\n        this._drawers.reset(drawer.filter(item => !item._container || item._container === this));\n        this._drawers.notifyOnChanges();\n      });\n      this._drawers.changes.pipe(startWith(null)).subscribe(() => {\n        this._validateDrawers();\n        this._drawers.forEach(drawer => {\n          this._watchDrawerToggle(drawer);\n          this._watchDrawerPosition(drawer);\n          this._watchDrawerMode(drawer);\n        });\n        if (!this._drawers.length || this._isDrawerOpen(this._start) || this._isDrawerOpen(this._end)) {\n          this.updateContentMargins();\n        }\n        this._changeDetectorRef.markForCheck();\n      });\n      // Avoid hitting the NgZone through the debounce timeout.\n      this._ngZone.runOutsideAngular(() => {\n        this._doCheckSubject.pipe(debounceTime(10),\n        // Arbitrary debounce time, less than a frame at 60fps\n        takeUntil(this._destroyed)).subscribe(() => this.updateContentMargins());\n      });\n    }\n    ngOnDestroy() {\n      this._contentMarginChanges.complete();\n      this._doCheckSubject.complete();\n      this._drawers.destroy();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    /** Calls `open` of both start and end drawers */\n    open() {\n      this._drawers.forEach(drawer => drawer.open());\n    }\n    /** Calls `close` of both start and end drawers */\n    close() {\n      this._drawers.forEach(drawer => drawer.close());\n    }\n    /**\n     * Recalculates and updates the inline styles for the content. Note that this should be used\n     * sparingly, because it causes a reflow.\n     */\n    updateContentMargins() {\n      // 1. For drawers in `over` mode, they don't affect the content.\n      // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\n      //    left margin (for left drawer) or right margin (for right the drawer).\n      // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\n      //    adding to the left or right margin and simultaneously subtracting the same amount of\n      //    margin from the other side.\n      let left = 0;\n      let right = 0;\n      if (this._left && this._left.opened) {\n        if (this._left.mode == 'side') {\n          left += this._left._getWidth();\n        } else if (this._left.mode == 'push') {\n          const width = this._left._getWidth();\n          left += width;\n          right -= width;\n        }\n      }\n      if (this._right && this._right.opened) {\n        if (this._right.mode == 'side') {\n          right += this._right._getWidth();\n        } else if (this._right.mode == 'push') {\n          const width = this._right._getWidth();\n          right += width;\n          left -= width;\n        }\n      }\n      // If either `right` or `left` is zero, don't set a style to the element. This\n      // allows users to specify a custom size via CSS class in SSR scenarios where the\n      // measured widths will always be zero. Note that we reset to `null` here, rather\n      // than below, in order to ensure that the types in the `if` below are consistent.\n      left = left || null;\n      right = right || null;\n      if (left !== this._contentMargins.left || right !== this._contentMargins.right) {\n        this._contentMargins = {\n          left,\n          right\n        };\n        // Pull back into the NgZone since in some cases we could be outside. We need to be careful\n        // to do it only when something changed, otherwise we can end up hitting the zone too often.\n        this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins));\n      }\n    }\n    ngDoCheck() {\n      // If users opted into autosizing, do a check every change detection cycle.\n      if (this._autosize && this._isPushed()) {\n        // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\n        this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());\n      }\n    }\n    /**\n     * Subscribes to drawer events in order to set a class on the main container element when the\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n     * is properly hidden.\n     */\n    _watchDrawerToggle(drawer) {\n      drawer._animationStarted.pipe(takeUntil(this._drawers.changes)).subscribe(() => {\n        this.updateContentMargins();\n        this._changeDetectorRef.markForCheck();\n      });\n      if (drawer.mode !== 'side') {\n        drawer.openedChange.pipe(takeUntil(this._drawers.changes)).subscribe(() => this._setContainerClass(drawer.opened));\n      }\n    }\n    /**\n     * Subscribes to drawer onPositionChanged event in order to\n     * re-validate drawers when the position changes.\n     */\n    _watchDrawerPosition(drawer) {\n      // NOTE: We need to wait for the microtask queue to be empty before validating,\n      // since both drawers may be swapping positions at the same time.\n      drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(() => {\n        afterNextRender({\n          read: () => this._validateDrawers()\n        }, {\n          injector: this._injector\n        });\n      });\n    }\n    /** Subscribes to changes in drawer mode so we can run change detection. */\n    _watchDrawerMode(drawer) {\n      drawer._modeChanged.pipe(takeUntil(merge(this._drawers.changes, this._destroyed))).subscribe(() => {\n        this.updateContentMargins();\n        this._changeDetectorRef.markForCheck();\n      });\n    }\n    /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\n    _setContainerClass(isAdd) {\n      const classList = this._element.nativeElement.classList;\n      const className = 'mat-drawer-container-has-open';\n      if (isAdd) {\n        classList.add(className);\n      } else {\n        classList.remove(className);\n      }\n    }\n    /** Validate the state of the drawer children components. */\n    _validateDrawers() {\n      this._start = this._end = null;\n      // Ensure that we have at most one start and one end drawer.\n      this._drawers.forEach(drawer => {\n        if (drawer.position == 'end') {\n          if (this._end != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throwMatDuplicatedDrawerError('end');\n          }\n          this._end = drawer;\n        } else {\n          if (this._start != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throwMatDuplicatedDrawerError('start');\n          }\n          this._start = drawer;\n        }\n      });\n      this._right = this._left = null;\n      // Detect if we're LTR or RTL.\n      if (this._dir && this._dir.value === 'rtl') {\n        this._left = this._end;\n        this._right = this._start;\n      } else {\n        this._left = this._start;\n        this._right = this._end;\n      }\n    }\n    /** Whether the container is being pushed to the side by one of the drawers. */\n    _isPushed() {\n      return this._isDrawerOpen(this._start) && this._start.mode != 'over' || this._isDrawerOpen(this._end) && this._end.mode != 'over';\n    }\n    _onBackdropClicked() {\n      this.backdropClick.emit();\n      this._closeModalDrawersViaBackdrop();\n    }\n    _closeModalDrawersViaBackdrop() {\n      // Close all open drawers where closing is not disabled and the mode is not `side`.\n      [this._start, this._end].filter(drawer => drawer && !drawer.disableClose && this._drawerHasBackdrop(drawer)).forEach(drawer => drawer._closeViaBackdropClick());\n    }\n    _isShowingBackdrop() {\n      return this._isDrawerOpen(this._start) && this._drawerHasBackdrop(this._start) || this._isDrawerOpen(this._end) && this._drawerHasBackdrop(this._end);\n    }\n    _isDrawerOpen(drawer) {\n      return drawer != null && drawer.opened;\n    }\n    // Whether argument drawer should have a backdrop when it opens\n    _drawerHasBackdrop(drawer) {\n      if (this._backdropOverride == null) {\n        return !!drawer && drawer.mode !== 'side';\n      }\n      return this._backdropOverride;\n    }\n    static ɵfac = function MatDrawerContainer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDrawerContainer)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatDrawerContainer,\n      selectors: [[\"mat-drawer-container\"]],\n      contentQueries: function MatDrawerContainer_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, MatDrawerContent, 5);\n          i0.ɵɵcontentQuery(dirIndex, MatDrawer, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._content = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._allDrawers = _t);\n        }\n      },\n      viewQuery: function MatDrawerContainer_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(MatDrawerContent, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._userContent = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mat-drawer-container\"],\n      hostVars: 2,\n      hostBindings: function MatDrawerContainer_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"mat-drawer-container-explicit-backdrop\", ctx._backdropOverride);\n        }\n      },\n      inputs: {\n        autosize: \"autosize\",\n        hasBackdrop: \"hasBackdrop\"\n      },\n      outputs: {\n        backdropClick: \"backdropClick\"\n      },\n      exportAs: [\"matDrawerContainer\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MAT_DRAWER_CONTAINER,\n        useExisting: MatDrawerContainer\n      }])],\n      ngContentSelectors: _c3,\n      decls: 4,\n      vars: 2,\n      consts: [[1, \"mat-drawer-backdrop\", 3, \"mat-drawer-shown\"], [1, \"mat-drawer-backdrop\", 3, \"click\"]],\n      template: function MatDrawerContainer_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c2);\n          i0.ɵɵconditionalCreate(0, MatDrawerContainer_Conditional_0_Template, 1, 2, \"div\", 0);\n          i0.ɵɵprojection(1);\n          i0.ɵɵprojection(2, 1);\n          i0.ɵɵconditionalCreate(3, MatDrawerContainer_Conditional_3_Template, 2, 0, \"mat-drawer-content\");\n        }\n        if (rf & 2) {\n          i0.ɵɵconditional(ctx.hasBackdrop ? 0 : -1);\n          i0.ɵɵadvance(3);\n          i0.ɵɵconditional(!ctx._content ? 3 : -1);\n        }\n      },\n      dependencies: [MatDrawerContent],\n      styles: [\".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatDrawerContainer;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatSidenavContent = /*#__PURE__*/(() => {\n  class MatSidenavContent extends MatDrawerContent {\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatSidenavContent_BaseFactory;\n      return function MatSidenavContent_Factory(__ngFactoryType__) {\n        return (ɵMatSidenavContent_BaseFactory || (ɵMatSidenavContent_BaseFactory = i0.ɵɵgetInheritedFactory(MatSidenavContent)))(__ngFactoryType__ || MatSidenavContent);\n      };\n    })();\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatSidenavContent,\n      selectors: [[\"mat-sidenav-content\"]],\n      hostAttrs: [1, \"mat-drawer-content\", \"mat-sidenav-content\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: CdkScrollable,\n        useExisting: MatSidenavContent\n      }]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c0,\n      decls: 1,\n      vars: 0,\n      template: function MatSidenavContent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatSidenavContent;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatSidenav = /*#__PURE__*/(() => {\n  class MatSidenav extends MatDrawer {\n    /** Whether the sidenav is fixed in the viewport. */\n    get fixedInViewport() {\n      return this._fixedInViewport;\n    }\n    set fixedInViewport(value) {\n      this._fixedInViewport = coerceBooleanProperty(value);\n    }\n    _fixedInViewport = false;\n    /**\n     * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\n     * mode.\n     */\n    get fixedTopGap() {\n      return this._fixedTopGap;\n    }\n    set fixedTopGap(value) {\n      this._fixedTopGap = coerceNumberProperty(value);\n    }\n    _fixedTopGap = 0;\n    /**\n     * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\n     * fixed mode.\n     */\n    get fixedBottomGap() {\n      return this._fixedBottomGap;\n    }\n    set fixedBottomGap(value) {\n      this._fixedBottomGap = coerceNumberProperty(value);\n    }\n    _fixedBottomGap = 0;\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatSidenav_BaseFactory;\n      return function MatSidenav_Factory(__ngFactoryType__) {\n        return (ɵMatSidenav_BaseFactory || (ɵMatSidenav_BaseFactory = i0.ɵɵgetInheritedFactory(MatSidenav)))(__ngFactoryType__ || MatSidenav);\n      };\n    })();\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatSidenav,\n      selectors: [[\"mat-sidenav\"]],\n      hostAttrs: [1, \"mat-drawer\", \"mat-sidenav\"],\n      hostVars: 16,\n      hostBindings: function MatSidenav_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"tabIndex\", ctx.mode !== \"side\" ? \"-1\" : null)(\"align\", null);\n          i0.ɵɵstyleProp(\"top\", ctx.fixedInViewport ? ctx.fixedTopGap : null, \"px\")(\"bottom\", ctx.fixedInViewport ? ctx.fixedBottomGap : null, \"px\");\n          i0.ɵɵclassProp(\"mat-drawer-end\", ctx.position === \"end\")(\"mat-drawer-over\", ctx.mode === \"over\")(\"mat-drawer-push\", ctx.mode === \"push\")(\"mat-drawer-side\", ctx.mode === \"side\")(\"mat-sidenav-fixed\", ctx.fixedInViewport);\n        }\n      },\n      inputs: {\n        fixedInViewport: \"fixedInViewport\",\n        fixedTopGap: \"fixedTopGap\",\n        fixedBottomGap: \"fixedBottomGap\"\n      },\n      exportAs: [\"matSidenav\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MatDrawer,\n        useExisting: MatSidenav\n      }]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c0,\n      decls: 3,\n      vars: 0,\n      consts: [[\"content\", \"\"], [\"cdkScrollable\", \"\", 1, \"mat-drawer-inner-container\"]],\n      template: function MatSidenav_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", 1, 0);\n          i0.ɵɵprojection(2);\n          i0.ɵɵelementEnd();\n        }\n      },\n      dependencies: [CdkScrollable],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatSidenav;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatSidenavContainer = /*#__PURE__*/(() => {\n  class MatSidenavContainer extends MatDrawerContainer {\n    _allDrawers = undefined;\n    // We need an initializer here to avoid a TS error.\n    _content = undefined;\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatSidenavContainer_BaseFactory;\n      return function MatSidenavContainer_Factory(__ngFactoryType__) {\n        return (ɵMatSidenavContainer_BaseFactory || (ɵMatSidenavContainer_BaseFactory = i0.ɵɵgetInheritedFactory(MatSidenavContainer)))(__ngFactoryType__ || MatSidenavContainer);\n      };\n    })();\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatSidenavContainer,\n      selectors: [[\"mat-sidenav-container\"]],\n      contentQueries: function MatSidenavContainer_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, MatSidenavContent, 5);\n          i0.ɵɵcontentQuery(dirIndex, MatSidenav, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._content = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._allDrawers = _t);\n        }\n      },\n      hostAttrs: [1, \"mat-drawer-container\", \"mat-sidenav-container\"],\n      hostVars: 2,\n      hostBindings: function MatSidenavContainer_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"mat-drawer-container-explicit-backdrop\", ctx._backdropOverride);\n        }\n      },\n      exportAs: [\"matSidenavContainer\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MAT_DRAWER_CONTAINER,\n        useExisting: MatSidenavContainer\n      }, {\n        provide: MatDrawerContainer,\n        useExisting: MatSidenavContainer\n      }]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c5,\n      decls: 4,\n      vars: 2,\n      consts: [[1, \"mat-drawer-backdrop\", 3, \"mat-drawer-shown\"], [1, \"mat-drawer-backdrop\", 3, \"click\"]],\n      template: function MatSidenavContainer_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c4);\n          i0.ɵɵconditionalCreate(0, MatSidenavContainer_Conditional_0_Template, 1, 2, \"div\", 0);\n          i0.ɵɵprojection(1);\n          i0.ɵɵprojection(2, 1);\n          i0.ɵɵconditionalCreate(3, MatSidenavContainer_Conditional_3_Template, 2, 0, \"mat-sidenav-content\");\n        }\n        if (rf & 2) {\n          i0.ɵɵconditional(ctx.hasBackdrop ? 0 : -1);\n          i0.ɵɵadvance(3);\n          i0.ɵɵconditional(!ctx._content ? 3 : -1);\n        }\n      },\n      dependencies: [MatSidenavContent],\n      styles: [_c6],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatSidenavContainer;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatSidenavModule = /*#__PURE__*/(() => {\n  class MatSidenavModule {\n    static ɵfac = function MatSidenavModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSidenavModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatSidenavModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [MatCommonModule, CdkScrollableModule, CdkScrollableModule, MatCommonModule]\n    });\n  }\n  return MatSidenavModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Animations used by the Material drawers.\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nconst matDrawerAnimations = {\n  // Represents\n  // trigger('transform', [\n  //   // We remove the `transform` here completely, rather than setting it to zero, because:\n  //   // 1. Having a transform can cause elements with ripples or an animated\n  //   //    transform to shift around in Chrome with an RTL layout (see #10023).\n  //   // 2. 3d transforms causes text to appear blurry on IE and Edge.\n  //   state(\n  //     'open, open-instant',\n  //     style({\n  //       'transform': 'none',\n  //       'visibility': 'visible',\n  //     }),\n  //   ),\n  //   state(\n  //     'void',\n  //     style({\n  //       // Avoids the shadow showing up when closed in SSR.\n  //       'box-shadow': 'none',\n  //       'visibility': 'hidden',\n  //     }),\n  //   ),\n  //   transition('void => open-instant', animate('0ms')),\n  //   transition(\n  //     'void <=> open, open-instant => void',\n  //     animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'),\n  //   ),\n  // ])\n  /** Animation that slides a drawer in and out. */\n  transformDrawer: {\n    type: 7,\n    name: 'transform',\n    definitions: [{\n      type: 0,\n      name: 'open, open-instant',\n      styles: {\n        type: 6,\n        styles: {\n          transform: 'none',\n          visibility: 'visible'\n        },\n        offset: null\n      }\n    }, {\n      type: 0,\n      name: 'void',\n      styles: {\n        type: 6,\n        styles: {\n          'box-shadow': 'none',\n          visibility: 'hidden'\n        },\n        offset: null\n      }\n    }, {\n      type: 1,\n      expr: 'void => open-instant',\n      animation: {\n        type: 4,\n        styles: null,\n        timings: '0ms'\n      },\n      options: null\n    }, {\n      type: 1,\n      expr: 'void <=> open, open-instant => void',\n      animation: {\n        type: 4,\n        styles: null,\n        timings: '400ms cubic-bezier(0.25, 0.8, 0.25, 1)'\n      },\n      options: null\n    }],\n    options: {}\n  }\n};\nexport { MAT_DRAWER_DEFAULT_AUTOSIZE, MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY, MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent, MatSidenavModule, matDrawerAnimations, throwMatDuplicatedDrawerError };\n","import { CdkPortal, DomPortalOutlet, PortalModule } from '@angular/cdk/portal';\nimport {\n  Component,\n  OnDestroy,\n  afterNextRender,\n  input,\n  viewChild,\n} from '@angular/core';\n\n@Component({\n  selector: 'showcase-layout-toolbar-menu',\n  template: `\n    <ng-template cdk-portal>\n      <ng-content></ng-content>\n    </ng-template>\n  `,\n  imports: [PortalModule],\n})\nexport class LayoutToolbarMenuComponent implements OnDestroy {\n\n  readonly position = input<'left' | 'right'>();\n\n  private portalOutlet: DomPortalOutlet;\n  readonly portal = viewChild.required(CdkPortal);\n\n  constructor() {\n    afterNextRender(() => {\n      this.portalOutlet = new DomPortalOutlet(\n        document.querySelector(\n          this.position() === 'left'\n            ? '#layout-left-custom-items'\n            : '#layout-right-custom-items'\n        )!\n      );\n      this.portalOutlet.attach(this.portal());\n    });\n  }\n\n  ngOnDestroy(): void {\n    this.portalOutlet?.detach()\n  }\n}\n","import {\n  Component,\n  ElementRef,\n  afterNextRender,\n  computed,\n  inject,\n  model,\n  signal,\n  viewChildren,\n} from '@angular/core';\nimport {\n  MatSlideToggleChange,\n  MatSlideToggleModule,\n} from '@angular/material/slide-toggle';\nimport {\n  ActivatedRoute,\n  Router,\n  Routes,\n  RouterLinkActive,\n  RouterLink,\n  RouterOutlet,\n  Data,\n} from '@angular/router';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport { CATEGORIES, DEMO_ROUTES } from './routes';\nimport { MatDividerModule } from '@angular/material/divider';\nimport { MatListModule } from '@angular/material/list';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatSidenavModule } from '@angular/material/sidenav';\nimport { FormsModule } from '@angular/forms';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatButtonModule } from '@angular/material/button';\nimport { LayoutToolbarMenuComponent } from '../shared/layout/layout-toolbar-menu.component';\n\ntype RoutesByCategory = Record<string, Routes>;\n\n@Component({\n  templateUrl: './demo-index.component.html',\n  styleUrls: ['./demo-index.component.scss'],\n  imports: [\n    LayoutToolbarMenuComponent,\n    MatButtonModule,\n    MatIconModule,\n    MatSlideToggleModule,\n    FormsModule,\n    MatSidenavModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatListModule,\n    RouterLinkActive,\n    RouterLink,\n    MatDividerModule,\n    RouterOutlet,\n  ],\n})\nexport class DemoIndexComponent {\n  private readonly router = inject(Router);\n  private readonly activatedRoute = inject(ActivatedRoute);\n\n  private readonly originalRoutes = <RoutesByCategory>(\n    (\n      Object.groupBy(DEMO_ROUTES[0].children ?? [], ({ data }) =>\n        data ? data.cat : null\n      )\n    )\n  );\n\n  readonly searchedRoutes = computed(() => {\n    const routesByCategory: RoutesByCategory = {};\n    const searchTerm = this.searchTerm().toLocaleLowerCase();\n\n    Object.values(this.originalRoutes).forEach((category) => {\n      category.forEach((route) => {\n        const label = this.getLabelFromData(route.data);\n        const category = route.data?.cat ?? ''\n        if (label.toLocaleLowerCase().includes(searchTerm)) {\n          if (!routesByCategory[category]) { routesByCategory[category] = []; }\n          routesByCategory[category].push(route);\n        };\n\n      });\n    });\n    return routesByCategory;\n  });\n\n  readonly categories = Object.values(CATEGORIES);\n  readonly searchTerm = model('');\n  readonly sidenavIsOpen = signal(true);\n  readonly isEditMode = model(!!this.activatedRoute.snapshot.firstChild!.params.demoUrl);\n\n  readonly exampleLinks = viewChildren<string, ElementRef>('exampleLink', {\n    read: ElementRef,\n  });\n\n  constructor() {\n    afterNextRender(() => {\n      // workaround: active class is not applied by the router directly\n      setTimeout(() => {\n        this.scrollInToActiveExampleLink();\n      }, 0);\n    });\n  }\n\n\n  getLabelFromData(data: Data | undefined): string {\n    if (data && typeof data.label === 'string') {\n      return data.label;\n    }\n    return '';\n  }\n\n  toggleSidenav() {\n    this.sidenavIsOpen.update((v) => !v);\n  }\n\n  toggleEdit(change: MatSlideToggleChange) {\n    const snapshot = this.activatedRoute.snapshot.firstChild!;\n    if (change.checked) {\n      this.router.navigate(['demo', 'edit', snapshot.url[0].path]);\n    } else {\n      this.router.navigate(['demo', snapshot.params.demoUrl]);\n    }\n  }\n\n\n  clearSearch() {\n    this.searchTerm.set('');\n  }\n\n  private scrollInToActiveExampleLink() {\n    const activeLink = this.exampleLinks().find((elm) =>\n      (<HTMLElement>elm.nativeElement).classList.contains('active')\n    );\n    if (activeLink) {\n      scrollIntoView(<HTMLElement>activeLink.nativeElement, {\n        block: 'center',\n        scrollMode: 'if-needed',\n      });\n    }\n  }\n}\n","<showcase-layout-toolbar-menu position=\"left\">\n  <button class=\"menu-button\" mat-icon-button (click)=\"toggleSidenav()\">\n    <mat-icon>menu</mat-icon>\n  </button>\n</showcase-layout-toolbar-menu>\n<showcase-layout-toolbar-menu position=\"right\">\n  <mat-slide-toggle\n    color=\"accent\"\n    [(ngModel)]=\"isEditMode\"\n    (change)=\"toggleEdit($event)\"\n  >\n    Edit!\n  </mat-slide-toggle>\n</showcase-layout-toolbar-menu>\n<mat-sidenav-container>\n  <mat-sidenav\n    #sidenav\n    mode=\"side\"\n    [opened]=\"sidenavIsOpen()\"\n  >\n    <mat-form-field class=\"search\">\n      <input\n        matInput\n        type=\"text\"\n        placeholder=\"Search\"\n        [(ngModel)]=\"searchTerm\"\n     \n      />\n      @if (searchTerm()) {\n        <button\n          matSuffix\n          mat-icon-button\n          aria-label=\"Clear\"\n          (click)=\"clearSearch()\"\n        >\n          <mat-icon>close</mat-icon>\n        </button>\n      }\n    </mat-form-field>\n    <mat-nav-list>\n      @for (cat of categories; track cat) {\n        <h3 matSubheader>{{ cat }}</h3>\n        @for (route of searchedRoutes()[cat]; track route) {\n          @if (route) {\n            <a\n              mat-list-item\n              [routerLink]=\"\n                '/demo/' + (isEditMode() ? '/edit/' : '') + route.path\n              \"\n              routerLinkActive=\"active\"\n              [routerLinkActiveOptions]=\"{\n                _routerLinkActiveWakeUpHack_: isEditMode(),\n              }\"\n              #exampleLink\n            >\n              {{ route.data?.label }}\n            </a>\n          }\n        }\n        <mat-divider />\n      }\n    </mat-nav-list>\n  </mat-sidenav>\n  <mat-sidenav-content>\n    <section class=\"content\">\n      <router-outlet/>\n    </section>\n  </mat-sidenav-content>\n</mat-sidenav-container>\n"],"mappings":"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","names":["_c0","_c1","MatSlideToggle_Conditional_10_Template","rf","ctx","ɵɵelementStart","ɵɵnamespaceSVG","ɵɵelement","ɵɵelementEnd","MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS","InjectionToken","MatSlideToggleChange","source","checked","MatSlideToggle","inject","ElementRef","FocusMonitor","ChangeDetectorRef","_","isChecked","_animationsDisabled","value","EventEmitter","_CdkPrivateStyleLoader","_StructuralStylesLoader","tabIndex","HostAttributeToken","defaults","_IdGenerator","focusOrigin","changes","fn","control","isDisabled","__ngFactoryType__","ɵɵdefineComponent","ɵɵviewQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","ɵɵdomProperty","ɵɵattribute","ɵɵclassMap","ɵɵclassProp","booleanAttribute","numberAttribute","ɵɵProvidersFeature","NG_VALUE_ACCESSOR","forwardRef","NG_VALIDATORS","ɵɵNgOnChangesFeature","_r1","ɵɵgetCurrentView","ɵɵprojectionDef","ɵɵlistener","ɵɵrestoreView","ɵɵresetView","ɵɵconditionalCreate","$event","ɵɵprojection","switch_r2","ɵɵreference","ɵɵproperty","ɵɵadvance","ɵɵconditional","MatRipple","_MatInternalFormField","MatSlideToggleModule","ɵɵdefineNgModule","ɵɵdefineInjector","MatCommonModule","isElement","el","t","nodeType","overflow","skipOverflowHiddenElements","_CdkTextFieldStyleLoader","__ngFactoryType__","ɵɵdefineComponent","rf","ctx","listenerOptions","AutofillMonitor","inject","Platform","NgZone","RendererFactory2","_CdkPrivateStyleLoader","elementOrRef","EMPTY","element","coerceElement","info","subject","Subject","cssClass","listener","event","unlisten","_info","ɵɵdefineInjectable","TextFieldModule","__ngFactoryType__","ɵɵdefineNgModule","ɵɵdefineInjector","MAT_INPUT_VALUE_ACCESSOR","InjectionToken","MAT_INPUT_INVALID_TYPES","MAT_INPUT_CONFIG","InjectionToken","MatInput","inject","ElementRef","Platform","NgControl","AutofillMonitor","NgZone","MAT_FORM_FIELD","Renderer2","_IdGenerator","Subject","value","coerceBooleanProperty","Validators","prevType","getSupportedInputTypes","t","parentForm","NgForm","parentFormGroup","FormGroupDirective","defaultErrorStateMatcher","ErrorStateMatcher","accessor","MAT_INPUT_VALUE_ACCESSOR","element","nodeName","isSignal","_ErrorStateTracker","effect","event","options","isFocused","newValue","placeholder","validity","selectElement","firstOption","ids","el","__ngFactoryType__","ɵɵdefineDirective","rf","ctx","ɵɵlistener","ɵɵdomProperty","ɵɵattribute","ɵɵclassProp","booleanAttribute","ɵɵProvidersFeature","MatFormFieldControl","ɵɵNgOnChangesFeature","MatInputModule","ɵɵdefineNgModule","ɵɵdefineInjector","MatCommonModule","MatFormFieldModule","TextFieldModule","_c0","_c1","_c2","_c3","MatDrawerContainer_Conditional_0_Template","rf","ctx","_r1","ɵɵgetCurrentView","ɵɵelementStart","ɵɵlistener","ɵɵrestoreView","ctx_r1","ɵɵnextContext","ɵɵresetView","ɵɵelementEnd","ɵɵclassProp","MatDrawerContainer_Conditional_3_Template","ɵɵprojection","_c4","_c5","MatSidenavContainer_Conditional_0_Template","MatSidenavContainer_Conditional_3_Template","_c6","MAT_DRAWER_DEFAULT_AUTOSIZE","InjectionToken","MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY","MAT_DRAWER_CONTAINER","MatDrawerContent","CdkScrollable","inject","Platform","ChangeDetectorRef","MatDrawerContainer","elementRef","ElementRef","scrollDispatcher","ScrollDispatcher","ngZone","NgZone","start","end","__ngFactoryType__","ɵɵdefineComponent","rf","ctx","ɵɵstyleProp","ɵɵclassProp","ɵɵProvidersFeature","ɵɵInheritDefinitionFeature","_c0","ɵɵprojectionDef","ɵɵprojection","MatDrawer","FocusTrapFactory","FocusMonitor","Renderer2","InteractivityChecker","DOCUMENT","value","coerceBooleanProperty","signal","Subject","EventEmitter","filter","o","map","mapTo","Injector","takeUntil","opened","element","fromEvent","event","hasModifierKey","options","callback","cleanupBlur","cleanupMousedown","selector","elementToFocus","afterNextRender","focusOrigin","activeEl","cleanup","openedVia","isOpen","result","restoreFocus","resolve","take","open","isAnimating","newPosition","parent","ɵɵviewQuery","_c1","_t","ɵɵqueryRefresh","ɵɵloadQuery","ɵɵattribute","ɵɵelementStart","ɵɵelementEnd","Directionality","_animationsDisabled","QueryList","platform","viewportRuler","ViewportRuler","startWith","drawer","item","debounceTime","left","right","width","merge","isAdd","classList","className","dirIndex","ɵɵcontentQuery","_c3","_c2","ɵɵconditionalCreate","MatDrawerContainer_Conditional_0_Template","MatDrawerContainer_Conditional_3_Template","ɵɵconditional","ɵɵadvance","MatSidenavContent","ɵMatSidenavContent_BaseFactory","ɵɵgetInheritedFactory","MatSidenav","coerceNumberProperty","ɵMatSidenav_BaseFactory","MatSidenavContainer","ɵMatSidenavContainer_BaseFactory","_c5","_c4","MatSidenavContainer_Conditional_0_Template","MatSidenavContainer_Conditional_3_Template","_c6","MatSidenavModule","ɵɵdefineNgModule","ɵɵdefineInjector","MatCommonModule","CdkScrollableModule","ɵɵprojection","LayoutToolbarMenuComponent","constructor","position","input","portal","viewChild","required","CdkPortal","afterNextRender","portalOutlet","DomPortalOutlet","document","querySelector","attach","ngOnDestroy","detach","selectors","viewQuery","rf","ctx","ɵɵtemplate","LayoutToolbarMenuComponent_ng_template_0_Template","PortalModule","TemplatePortalDirective","encapsulation","_LayoutToolbarMenuComponent","ɵɵelementStart","ɵɵlistener","ɵɵrestoreView","_r2","ctx_r2","ɵɵnextContext","ɵɵresetView","clearSearch","ɵɵtext","ɵɵelementEnd","ɵɵproperty","isEditMode","route_r4","path","ɵɵpureFunction1","_c1","ɵɵadvance","ɵɵtextInterpolate1","data","label","ɵɵconditionalCreate","DemoIndexComponent_For_15_For_3_Conditional_0_Template","ɵɵconditional","ɵɵrepeaterCreate","DemoIndexComponent_For_15_For_3_Template","ɵɵrepeaterTrackByIdentity","ɵɵelement","ɵɵtextInterpolate","cat_r5","ɵɵrepeater","searchedRoutes","DemoIndexComponent","constructor","router","inject","Router","activatedRoute","ActivatedRoute","originalRoutes","Object","groupBy","DEMO_ROUTES","children","cat","computed","routesByCategory","searchTerm","toLocaleLowerCase","values","forEach","category","route","getLabelFromData","includes","push","categories","CATEGORIES","model","sidenavIsOpen","signal","snapshot","firstChild","params","demoUrl","exampleLinks","viewChildren","read","ElementRef","afterNextRender","setTimeout","scrollInToActiveExampleLink","toggleSidenav","update","v","toggleEdit","change","checked","navigate","url","set","activeLink","find","elm","nativeElement","classList","contains","scrollIntoView","block","scrollMode","selectors","viewQuery","rf","ctx","i0","_r1","ɵɵtwoWayListener","$event","ɵɵtwoWayBindingSet","DemoIndexComponent_Conditional_12_Template","DemoIndexComponent_For_15_Template","ɵɵtwoWayProperty","LayoutToolbarMenuComponent","MatButtonModule","MatIconButton","MatIconModule","MatIcon","MatSlideToggleModule","MatSlideToggle","FormsModule","DefaultValueAccessor","NgControlStatus","NgModel","MatSidenavModule","MatSidenav","MatSidenavContainer","MatSidenavContent","MatFormFieldModule","MatFormField","MatSuffix","MatInputModule","MatInput","MatListModule","MatNavList","MatListItem","MatListSubheaderCssMatStyler","MatDivider","RouterLinkActive","RouterLink","MatDividerModule","RouterOutlet","styles","_DemoIndexComponent"],"x_google_ignoreList":[0,1,2,3,4,5]}